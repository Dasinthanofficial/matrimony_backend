===== FILE: ./validators/authValidator.js =====
// ===== UPDATED FILE: ./validators/authValidator.js =====
import { body } from 'express-validator';

export const registerValidator = [
  body('email').isEmail().withMessage('Valid email required'),
  body('password').isLength({ min: 6 }).withMessage('Password min 6 chars'),
];

export const loginValidator = [
  body('email').isEmail().withMessage('Valid email required'),
  body('password').notEmpty().withMessage('Password required'),
];===== FILE: ./validators/adminValidator.js =====
import { body, param, query } from 'express-validator';

export const suspendUserValidator = [
  param('userId').isMongoId().withMessage('Invalid user ID'),
  body('reason').optional().trim().isLength({ max: 500 }).withMessage('Reason too long (max 500 characters)'),
];

export const resolveReportValidator = [
  param('reportId').isMongoId().withMessage('Invalid report ID'),
  body('action')
    .isIn(['none', 'warning', 'suspension', 'deletion'])
    .withMessage('Invalid action. Must be: none, warning, suspension, or deletion'),
  body('resolutionNote')
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Resolution note too long (max 1000 characters)'),
];

export const paginationValidator = [
  query('page').optional().isInt({ min: 1 }).withMessage('Page must be a positive integer'),
  query('limit').optional().isInt({ min: 1, max: 200 }).withMessage('Limit must be between 1 and 200'),
];===== FILE: ./validators/commonValidator.js =====
// ===== UPDATED FILE: ./validators/commonValidator.js =====
import { body, query, param } from 'express-validator';

// Create profile (required fields)
export const createProfileValidator = [
  body('fullName')
    .trim()
    .notEmpty().withMessage('Full name required')
    .isLength({ max: 100 }).withMessage('Name too long'),
  body('gender').isIn(['male','female']).withMessage('Invalid gender'),
  body('dateOfBirth').isISO8601().withMessage('Valid date required'),
  body('religion').trim().notEmpty().withMessage('Religion required'),
  body('country').trim().notEmpty().withMessage('Country required'),
  body('city').trim().notEmpty().withMessage('City required'),
  body('maritalStatus')
    .isIn(['never_married','divorced','widowed','awaiting_divorce','annulled'])
    .withMessage('Invalid marital status'),
];

// Update profile (all optional, but validated if present)
export const updateProfileValidator = [
  body('fullName')
    .optional()
    .trim()
    .notEmpty().withMessage('Full name required')
    .isLength({ max: 100 }).withMessage('Name too long'),
  body('gender')
    .optional()
    .isIn(['male','female']).withMessage('Invalid gender'),
  body('dateOfBirth')
    .optional()
    .isISO8601().withMessage('Valid date required'),
  body('religion')
    .optional()
    .trim()
    .notEmpty().withMessage('Religion required'),
  body('country')
    .optional()
    .trim()
    .notEmpty().withMessage('Country required'),
  body('city')
    .optional()
    .trim()
    .notEmpty().withMessage('City required'),
  body('maritalStatus')
    .optional()
    .isIn(['never_married','divorced','widowed','awaiting_divorce','annulled'])
    .withMessage('Invalid marital status'),
];

// Backwards compatibility (if anything else imports profileValidator)
export const profileValidator = createProfileValidator;

export const searchValidator = [
  query('page').optional().isInt({ min: 1 }).withMessage('Page must be positive integer'),
  query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('Limit must be 1–100'),
  query('minAge').optional().isInt({ min: 18, max: 100 }).withMessage('minAge must be 18–100'),
  query('maxAge').optional().isInt({ min: 18, max: 100 }).withMessage('maxAge must be 18–100'),
  query('religion').optional().trim().isLength({ max: 50 }).withMessage('Invalid religion'),
];

// Match Interest schema max length (200)
export const interestValidator = [
  body('receiverId')
    .notEmpty().withMessage('Receiver ID required')
    .isMongoId().withMessage('Invalid receiver ID'),
  body('message')
    .optional()
    .trim()
    .isLength({ max: 200 }).withMessage('Message too long (max 200 characters)'),
];

export const reportValidator = [
  body('reportedUserId')
    .notEmpty().withMessage('User ID required')
    .isMongoId().withMessage('Invalid user ID'),
  body('reportType')
    .isIn([
      'fake_profile','inappropriate_behavior','harassment',
      'inappropriate_content','scam','offensive_language','other'
    ])
    .withMessage('Invalid report type'),
  body('description')
    .trim()
    .notEmpty().withMessage('Description required')
    .isLength({ max: 500 }).withMessage('Description too long'),
  body('evidence')
    .optional()
    .isArray({ max: 10 }).withMessage('Evidence must be an array of up to 10 items'),
  body('evidence.*')
    .optional()
    .isString().withMessage('Evidence items must be strings')
    .trim()
    .notEmpty().withMessage('Evidence items must be non-empty strings'),
];

export const mongoIdValidator = [
  param('id').isMongoId().withMessage('Invalid ID format'),
];

// validate routes like /api/interests/:userId
export const userIdParamValidator = [
  param('userId').isMongoId().withMessage('Invalid user ID'),
];===== FILE: ./validators/searchValidator.js =====
import { query } from 'express-validator';
import { LIMITS, GENDERS, MARITAL_STATUSES, DIET_OPTIONS } from '../utils/constants.js';

const GENDERS_WITH_ALL = [...GENDERS, 'all'];

export const searchProfilesValidator = [
  query('page').optional().isInt({ min: 1 }).toInt().withMessage('Page must be a positive integer'),

  query('limit')
    .optional()
    .isInt({ min: 1, max: LIMITS.MAX_LIMIT_SEARCH })
    .toInt()
    .withMessage(`Limit must be between 1 and ${LIMITS.MAX_LIMIT_SEARCH}`),

  query('minAge').optional().isInt({ min: 18, max: 100 }).toInt().withMessage('minAge must be between 18 and 100'),

  query('maxAge').optional().isInt({ min: 18, max: 100 }).toInt().withMessage('maxAge must be between 18 and 100'),

  query('gender')
    .optional()
    .isIn(GENDERS_WITH_ALL)
    .withMessage(`Gender must be one of: ${GENDERS_WITH_ALL.join(', ')}`),

  query('maritalStatus').optional().isIn(MARITAL_STATUSES).withMessage('Invalid marital status'),

  query('diet').optional().isIn(DIET_OPTIONS).withMessage('Invalid diet option'),

  query('religion').optional().trim().isLength({ max: 50 }).withMessage('Religion must be less than 50 characters'),

  query('city').optional().trim().isLength({ max: 100 }).withMessage('City must be less than 100 characters'),

  query('state').optional().trim().isLength({ max: 100 }).withMessage('State must be less than 100 characters'),

  query('country').optional().trim().isLength({ max: 100 }).withMessage('Country must be less than 100 characters'),

  // ✅ Added: fields that frontend sends (or backend supports)
  query('education').optional().trim().isLength({ max: 50 }).withMessage('Education must be less than 50 characters'),
  query('occupation').optional().trim().isLength({ max: 100 }).withMessage('Occupation must be less than 100 characters'),
  query('caste').optional().trim().isLength({ max: 50 }).withMessage('Caste must be less than 50 characters'),
  query('smoking').optional().trim().isLength({ max: 20 }).withMessage('Smoking must be less than 20 characters'),
  query('drinking').optional().trim().isLength({ max: 20 }).withMessage('Drinking must be less than 20 characters'),

  query('sortBy')
    .optional()
    .isIn(['createdAt', 'age', 'completionPercentage', 'lastActive'])
    .withMessage('Invalid sort field'),

  query('sortOrder').optional().isIn(['asc', 'desc']).withMessage('Sort order must be asc or desc'),
];

export const quickSearchValidator = [
  query('page').optional().isInt({ min: 1 }).toInt().withMessage('Page must be a positive integer'),

  query('limit')
    .optional()
    .isInt({ min: 1, max: LIMITS.MAX_LIMIT_SEARCH })
    .toInt()
    .withMessage(`Limit must be between 1 and ${LIMITS.MAX_LIMIT_SEARCH}`),

  query('gender').optional().isIn(GENDERS_WITH_ALL).withMessage('Invalid gender'),

  query('minAge').optional().isInt({ min: 18, max: 100 }).toInt().withMessage('minAge must be between 18 and 100'),

  query('maxAge').optional().isInt({ min: 18, max: 100 }).toInt().withMessage('maxAge must be between 18 and 100'),

  query('religion').optional().trim().isLength({ max: 50 }).withMessage('Religion must be less than 50 characters'),

  query('city').optional().trim().isLength({ max: 100 }).withMessage('City must be less than 100 characters'),
];

export const suggestedProfilesValidator = [
  query('limit').optional().isInt({ min: 1, max: 50 }).toInt().withMessage('Limit must be between 1 and 50'),
];===== FILE: ./socket/socketHandler.js =====
// ===== FIXED FILE: ./socket/socketHandler.js =====
import jwt from 'jsonwebtoken';
import mongoose from 'mongoose';
import User from '../models/User.js';
import Message from '../models/Message.js';
import Conversation from '../models/Conversation.js';
import { hasPremiumAccess } from '../utils/entitlements.js';
import { LIMITS, CLEANUP_INTERVAL } from '../utils/constants.js';

const socketHandler = (io) => {
  const onlineUsers = new Map();
  let cleanupInterval = null;

  const addSocket = (userIdStr, socketId) => {
    const set = onlineUsers.get(userIdStr) || new Set();
    set.add(socketId);
    onlineUsers.set(userIdStr, set);
    return set.size;
  };

  const removeSocket = (userIdStr, socketId) => {
    const set = onlineUsers.get(userIdStr);
    if (!set) return 0;
    set.delete(socketId);
    if (set.size === 0) onlineUsers.delete(userIdStr);
    return set.size;
  };

  io.use(async (socket, next) => {
    try {
      const rawToken =
        socket.handshake.auth?.token ||
        socket.handshake.headers?.authorization ||
        socket.handshake.headers?.Authorization;

      const token = rawToken?.startsWith?.('Bearer ') ? rawToken.slice(7) : rawToken;
      if (!token) return next(new Error('Authentication required'));

      const secret = process.env.JWT_SECRET;
      if (!secret) {
        console.error('CRITICAL: JWT_SECRET not configured for socket auth');
        return next(new Error('Server configuration error'));
      }

      const decoded = jwt.verify(token, secret);

      const user = await User.findById(decoded.id).select('isSuspended isActive').lean();
      if (!user) return next(new Error('User not found'));
      if (user.isSuspended) return next(new Error('Account suspended'));
      if (user.isActive === false) return next(new Error('Account inactive'));

      socket.userId = decoded.id;
      next();
    } catch (error) {
      if (error.name === 'TokenExpiredError') return next(new Error('Token expired'));
      if (error.name === 'JsonWebTokenError') return next(new Error('Invalid token'));
      console.error('Socket auth error:', error.message);
      next(new Error('Authentication failed'));
    }
  });

  const runCleanup = async () => {
    try {
      const disconnectedUsers = [];

      onlineUsers.forEach((set, userIdStr) => {
        const alive = new Set();
        set.forEach((socketId) => {
          const s = io.sockets.sockets.get(socketId);
          if (s && s.connected) alive.add(socketId);
        });

        if (alive.size === 0) {
          disconnectedUsers.push(userIdStr);
        } else {
          onlineUsers.set(userIdStr, alive);
        }
      });

      for (const userIdStr of disconnectedUsers) {
        onlineUsers.delete(userIdStr);
        try {
          await User.findByIdAndUpdate(userIdStr, {
            isOnline: false,
            lastActive: new Date(),
            socketId: null,
          });
        } catch (e) {
          console.error(`Cleanup update error for user ${userIdStr}:`, e.message);
        }
      }

      if (disconnectedUsers.length > 0) {
        console.log(`Cleaned up ${disconnectedUsers.length} orphaned connections`);
      }
    } catch (error) {
      console.error('Cleanup error:', error.message);
    }
  };

  cleanupInterval = setInterval(runCleanup, CLEANUP_INTERVAL);

  const cleanup = () => {
    console.log('Socket handler cleanup initiated');

    if (cleanupInterval) {
      clearInterval(cleanupInterval);
      cleanupInterval = null;
    }

    const offlinePromises = [];
    onlineUsers.forEach((_set, userIdStr) => {
      offlinePromises.push(
        User.findByIdAndUpdate(userIdStr, {
          isOnline: false,
          lastActive: new Date(),
          socketId: null,
        }).catch((e) => console.error(`Shutdown cleanup error for ${userIdStr}:`, e.message))
      );
    });

    Promise.all(offlinePromises).then(() => {
      onlineUsers.clear();
      console.log('Socket handler cleanup completed');
    });
  };

  // ✅ FIX: Removed process.once('SIGTERM/SIGINT') — server.js manages lifecycle

  io.on('connection', async (socket) => {
    const userId = socket.userId;

    if (!userId) {
      console.error('Socket connection without userId');
      socket.disconnect(true);
      return;
    }

    const userIdStr = userId.toString();
    const wasOnline = onlineUsers.has(userIdStr);

    addSocket(userIdStr, socket.id);

    try {
      await User.findByIdAndUpdate(userId, {
        isOnline: true,
        lastActive: new Date(),
      });
    } catch (e) {
      console.error('Error updating user online status:', e.message);
    }

    if (!wasOnline) {
      socket.broadcast.emit('user_status_change', { userId, isOnline: true });
    }

    socket.on('join_conversation', async (conversationId) => {
      try {
        if (!conversationId || !mongoose.Types.ObjectId.isValid(conversationId)) {
          return socket.emit('error', { message: 'Invalid conversation ID' });
        }

        const conv = await Conversation.findById(conversationId).select('participants').lean();
        if (!conv) return socket.emit('error', { message: 'Conversation not found' });

        const isParticipant = conv.participants.some((p) => p.toString() === userId.toString());
        if (!isParticipant) return socket.emit('error', { message: 'Not authorized to join this conversation' });

        socket.join(conversationId);
        socket.emit('joined_conversation', { conversationId });
      } catch (e) {
        console.error('join_conversation error:', e.message);
        socket.emit('error', { message: 'Failed to join conversation' });
      }
    });

    socket.on('leave_conversation', (conversationId) => {
      if (conversationId && mongoose.Types.ObjectId.isValid(conversationId)) {
        socket.leave(conversationId);
      }
    });

    socket.on('send_message', async (data) => {
      try {
        const { conversationId, receiverId, content, messageType, clientId } = data || {};
        const fail = (msg) => socket.emit('message_error', { error: msg, clientId });

        if (!conversationId || !mongoose.Types.ObjectId.isValid(conversationId)) return fail('Invalid conversation ID');
        if (!receiverId || !mongoose.Types.ObjectId.isValid(receiverId)) return fail('Invalid receiver ID');
        if (typeof content !== 'string') return fail('Content must be a string');

        const trimmed = content.trim();
        if (!trimmed) return fail('Message cannot be empty');
        if (trimmed.length > LIMITS.MAX_MESSAGE_LENGTH) return fail(`Message too long (max ${LIMITS.MAX_MESSAGE_LENGTH} characters)`);

        const sender = await User.findById(userId).select('isPremium subscription isSuspended isActive premiumExpiry').lean();
        if (!sender) return fail('User not found');
        if (sender.isSuspended) return fail('Account suspended');
        if (sender.isActive === false) return fail('Account inactive');
        if (!hasPremiumAccess(sender)) return fail('Premium subscription required');

        // ✅ FIX: Validate receiver status
        const receiver = await User.findById(receiverId).select('isSuspended isActive').lean();
        if (!receiver) return fail('Receiver not found');
        if (receiver.isSuspended || receiver.isActive === false) return fail('Cannot message this user');

        const conversation = await Conversation.findById(conversationId).select('participants isBlocked blockedBy');
        if (!conversation) return fail('Conversation not found');
        if (conversation.isBlocked) return fail('Conversation is blocked');

        const senderOk = conversation.participants.some((p) => p.toString() === userId.toString());
        const receiverOk = conversation.participants.some((p) => p.toString() === receiverId.toString());
        if (!senderOk || !receiverOk) return fail('Not authorized');

        const message = await Message.create({
          conversationId,
          senderId: userId,
          receiverId,
          content: trimmed,
          messageType: messageType || 'text',
        });

        await Conversation.findByIdAndUpdate(conversationId, {
          lastMessage: { content: trimmed, senderId: userId, timestamp: new Date() },
          updatedAt: new Date(),
          $inc: { [`unreadCount.${receiverId.toString()}`]: 1 },
        });

        io.to(conversationId).emit('new_message', { ...message.toObject(), conversationId, clientId });

        const receiverSockets = onlineUsers.get(receiverId.toString());
        if (receiverSockets) {
          for (const sid of receiverSockets) {
            io.to(sid).emit('message_notification', {
              conversationId,
              senderId: userId,
              content: trimmed.substring(0, 100),
            });
          }
        }
      } catch (error) {
        console.error('Send message error:', error.message);
        socket.emit('message_error', { error: 'Failed to send message', clientId: data?.clientId });
      }
    });

    socket.on('typing', ({ conversationId } = {}) => {
      if (conversationId && mongoose.Types.ObjectId.isValid(conversationId)) {
        socket.to(conversationId).emit('user_typing', { userId, conversationId });
      }
    });

    socket.on('stop_typing', ({ conversationId } = {}) => {
      if (conversationId && mongoose.Types.ObjectId.isValid(conversationId)) {
        socket.to(conversationId).emit('user_stop_typing', { userId, conversationId });
      }
    });

    socket.on('mark_read', async ({ conversationId }) => {
      try {
        if (!conversationId || !mongoose.Types.ObjectId.isValid(conversationId)) {
          return socket.emit('error', { message: 'Invalid conversation ID' });
        }

        const conversation = await Conversation.findOne({ _id: conversationId, participants: userId });
        if (!conversation) return socket.emit('error', { message: 'Conversation not found' });

        await Message.updateMany(
          { conversationId, receiverId: userId, isRead: false },
          { isRead: true, readAt: new Date() }
        );

        await Conversation.findByIdAndUpdate(conversationId, {
          [`unreadCount.${userId.toString()}`]: 0,
        });

        io.to(conversationId).emit('messages_read', { conversationId, userId });
      } catch (error) {
        console.error('Mark read error:', error.message);
        socket.emit('error', { message: 'Failed to mark as read' });
      }
    });

    socket.on('disconnect', async () => {
      const remaining = removeSocket(userIdStr, socket.id);

      if (remaining === 0) {
        try {
          await User.findByIdAndUpdate(userId, {
            isOnline: false,
            lastActive: new Date(),
            socketId: null,
          });
        } catch (e) {
          console.error('Error updating user offline status:', e.message);
        }
        socket.broadcast.emit('user_status_change', { userId, isOnline: false });
      }
    });

    socket.on('error', (error) => {
      console.error(`Socket error for user ${userId}:`, error.message);
    });
  });

  io.on('close', cleanup);

  return {
    cleanup,
    getOnlineUsers: () => new Map([...onlineUsers].map(([k, v]) => [k, new Set(v)])),
  };
};

export default socketHandler;===== FILE: ./config/cloudinary.js =====
import { v2 as cloudinary } from 'cloudinary';

const {
  CLOUDINARY_NAME,
  CLOUDINARY_API_KEY,
  CLOUDINARY_API_SECRET,
} = process.env;

let hasCloudinary = false;

if (CLOUDINARY_NAME && CLOUDINARY_API_KEY && CLOUDINARY_API_SECRET) {
  cloudinary.config({
    cloud_name: CLOUDINARY_NAME,
    api_key: CLOUDINARY_API_KEY,
    api_secret: CLOUDINARY_API_SECRET,
  });
  hasCloudinary = true;
}

export default cloudinary;
export { hasCloudinary };===== FILE: ./config/db.js =====
import mongoose from 'mongoose';

const connectDB = async () => {
  try {
    const uri =
      process.env.MONGODB_URI ||
      process.env.MONGO_URI ||
      'mongodb://localhost:27017/matrimony';

    mongoose.set('strictQuery', false);
    await mongoose.connect(uri);

    console.log('MongoDB connected successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};

export default connectDB;===== FILE: ./controllers/reportController.js =====
// ===== FILE: ./controllers/reportController.js =====

import mongoose from 'mongoose';
import Report from '../models/Report.js';
import User from '../models/User.js';
import { handleControllerError } from '../utils/errors.js';
import { parsePagination, formatPaginationResponse } from '../utils/pagination.js';
import { LIMITS, REPORT_TYPES } from '../utils/constants.js';

export const createReport = async (req, res) => {
  try {
    const { reportedUserId, reportType, description, evidence = [] } = req.body;

    // Validate required fields
    if (!reportedUserId) {
      return res.status(400).json({ message: 'Reported user ID is required' });
    }

    if (!mongoose.Types.ObjectId.isValid(reportedUserId)) {
      return res.status(400).json({ message: 'Invalid reported user ID' });
    }

    if (!reportType) {
      return res.status(400).json({ message: 'Report type is required' });
    }

    if (!REPORT_TYPES.includes(reportType)) {
      return res.status(400).json({
        message: `Invalid report type. Must be one of: ${REPORT_TYPES.join(', ')}`,
      });
    }

    if (!description || !description.trim()) {
      return res.status(400).json({ message: 'Description is required' });
    }

    if (description.length > LIMITS.MAX_DESCRIPTION_LENGTH) {
      return res.status(400).json({
        message: `Description too long (max ${LIMITS.MAX_DESCRIPTION_LENGTH} characters)`,
      });
    }

    // Cannot report yourself
    if (reportedUserId.toString() === req.user._id.toString()) {
      return res.status(400).json({ message: 'Cannot report yourself' });
    }

    // Check if reported user exists
    const reportedUser = await User.exists({ _id: reportedUserId });
    if (!reportedUser) {
      return res.status(404).json({ message: 'Reported user not found' });
    }

    // Check for existing pending/under_review report
    const existing = await Report.findOne({
      reportedUserId,
      reportedByUserId: req.user._id,
      status: { $in: ['pending', 'under_review'] },
    });

    if (existing) {
      return res.status(400).json({
        message: 'You have already reported this user. Please wait for the existing report to be reviewed.',
        existingReportId: existing._id,
      });
    }

    // Validate evidence array
    const validEvidence = Array.isArray(evidence)
      ? evidence.filter((e) => typeof e === 'string' && e.trim()).slice(0, 10)
      : [];

    const report = await Report.create({
      reportedUserId,
      reportedByUserId: req.user._id,
      reportType,
      description: description.trim(),
      evidence: validEvidence,
    });

    res.status(201).json({
      message: 'Report submitted successfully. Our team will review it shortly.',
      report: {
        _id: report._id,
        reportType: report.reportType,
        status: report.status,
        createdAt: report.createdAt,
      },
    });
  } catch (e) {
    handleControllerError(res, e, 'Create report');
  }
};

export const getMyReports = async (req, res) => {
  try {
    const { status = 'all' } = req.query;
    const { page, limit, skip } = parsePagination(req.query);

    const filter = { reportedByUserId: req.user._id };

    // Validate status filter
    const validStatuses = ['all', 'pending', 'under_review', 'resolved', 'rejected', 'dismissed'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        message: `Invalid status. Must be one of: ${validStatuses.join(', ')}`,
      });
    }

    if (status !== 'all') {
      filter.status = status;
    }

    const [reports, total] = await Promise.all([
      Report.find(filter)
        .populate('reportedUserId', 'email')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .select('-evidence') // Don't include evidence in list view
        .lean(),
      Report.countDocuments(filter),
    ]);

    res.json({
      reports,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get my reports');
  }
};

export const getReportStatus = async (req, res) => {
  try {
    const { reportId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(reportId)) {
      return res.status(400).json({ message: 'Invalid report ID' });
    }

    const report = await Report.findById(reportId)
      .populate('reportedUserId', 'email')
      .lean();

    if (!report) {
      return res.status(404).json({ message: 'Report not found' });
    }

    // Only allow the reporter to view their own report details
    if (report.reportedByUserId.toString() !== req.user._id.toString()) {
      return res.status(403).json({ message: 'Not authorized to view this report' });
    }

    // Return report with appropriate fields based on status
    const response = {
      _id: report._id,
      reportType: report.reportType,
      description: report.description,
      status: report.status,
      createdAt: report.createdAt,
      reportedUser: report.reportedUserId,
    };

    // Include resolution info if resolved
    if (report.status === 'resolved' || report.status === 'rejected') {
      response.resolvedAt = report.resolvedAt;
      response.resolutionNote = report.resolutionNote;
      response.action = report.action;
    }

    res.json(response);
  } catch (e) {
    handleControllerError(res, e, 'Get report status');
  }
};

// Get report statistics for user (how many reports they've made)
export const getMyReportStats = async (req, res) => {
  try {
    const userId = req.user._id;

    const stats = await Report.aggregate([
      { $match: { reportedByUserId: userId } },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
        },
      },
    ]);

    const formattedStats = {
      total: 0,
      pending: 0,
      under_review: 0,
      resolved: 0,
      rejected: 0,
      dismissed: 0,
    };

    stats.forEach((stat) => {
      formattedStats[stat._id] = stat.count;
      formattedStats.total += stat.count;
    });

    res.json({ stats: formattedStats });
  } catch (e) {
    handleControllerError(res, e, 'Get report stats');
  }
};===== FILE: ./controllers/searchController.js =====
import Profile from '../models/Profile.js';
import User from '../models/User.js';
import Interest from '../models/Interest.js';
import { handleControllerError } from '../utils/errors.js';
import { parsePagination, formatPaginationResponse } from '../utils/pagination.js';
import { LIMITS } from '../utils/constants.js';
import { applyProfilePrivacy } from '../utils/privacy.js';

// Escape regex special characters to prevent injection
const escapeRegex = (str) => {
  if (!str || typeof str !== 'string') return '';
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

// Build set of userIds that are mutual matches with viewer (both directions accepted)
const buildMatchSet = async (viewerId, candidateUserIds) => {
  if (!viewerId || !candidateUserIds?.length) return new Set();

  const edges = await Interest.find({
    status: 'accepted',
    $or: [
      { senderId: viewerId, receiverId: { $in: candidateUserIds } },
      { receiverId: viewerId, senderId: { $in: candidateUserIds } },
    ],
  })
    .select('senderId receiverId')
    .lean();

  const viewerStr = viewerId.toString();
  const counts = new Map();

  for (const e of edges) {
    const s = e.senderId.toString();
    const r = e.receiverId.toString();
    const other = s === viewerStr ? r : s;
    counts.set(other, (counts.get(other) || 0) + 1);
  }

  const set = new Set();
  counts.forEach((count, otherId) => {
    if (count >= 2) set.add(otherId);
  });

  return set;
};

/**
 * Format single profile with user data + apply privacy
 */
const formatProfileWithUserData = async (profile, viewer) => {
  const user = await User.findById(profile.userId)
    .select('_id isPremium isEmailVerified isPhoneVerified createdAt role subscription premiumExpiry')
    .lean()
    .catch(() => null);

  let photoUrl = null;
  if (profile.photos?.length > 0) {
    const mainPhoto = profile.photos.find((p) => p.isProfile) || profile.photos[0];
    photoUrl = mainPhoto?.url || null;
  }

  const isVerified = Boolean(profile.isVerified || user?.isEmailVerified || user?.isPhoneVerified);

  const raw = {
    _id: profile._id,
    id: profile.userId,
    userId: profile.userId,

    role: user?.role || 'user',
    isPremium: user?.isPremium || false,
    isEmailVerified: user?.isEmailVerified || false,
    isPhoneVerified: user?.isPhoneVerified || false,
    isVerified,

    createdAt: user?.createdAt || profile.createdAt,

    profileId: profile.profileId || profile._id?.toString(),
    fullName: profile.fullName,
    age: profile.age,
    gender: profile.gender,
    city: profile.city,
    state: profile.state,
    country: profile.country,
    occupation: profile.occupation,
    education: profile.education,
    religion: profile.religion,
    caste: profile.caste,
    maritalStatus: profile.maritalStatus,
    diet: profile.diet,
    smoking: profile.smoking,
    drinking: profile.drinking,
    height: profile.height,
    weight: profile.weight,
    bodyType: profile.bodyType,
    bio: profile.bio,
    annualIncome: profile.annualIncome,

    photoUrl,
    photos: profile.photos || [],
    completionPercentage: profile.completionPercentage || 0,
    completionDetails: profile.completionDetails || {},
    lastActive: profile.lastActive,

    privacySettings: profile.privacySettings,
  };

  const matchSet = await buildMatchSet(viewer?._id, [profile.userId]);
  const isMatch = matchSet.has(profile.userId?.toString());

  const safe = applyProfilePrivacy({ viewer, profile: raw, isMatch });
  delete safe.privacySettings;
  if (safe.photosLocked) safe.photoUrl = null;

  return safe;
};

/**
 * Format multiple profiles with batch user data fetching + apply privacy
 */
const formatProfilesWithUserData = async (profiles, viewer) => {
  if (!profiles || profiles.length === 0) return [];

  const userIds = profiles.map((p) => p.userId).filter(Boolean);

  const users = await User.find({ _id: { $in: userIds } })
    .select('_id isPremium isEmailVerified isPhoneVerified createdAt role subscription premiumExpiry')
    .lean();

  const userMap = {};
  users.forEach((u) => {
    userMap[u._id.toString()] = u;
  });

  const matchSet = await buildMatchSet(viewer?._id, userIds);

  return profiles.map((profile) => {
    const user = userMap[profile.userId?.toString()] || null;

    let photoUrl = null;
    if (profile.photos?.length > 0) {
      const mainPhoto = profile.photos.find((p) => p.isProfile) || profile.photos[0];
      photoUrl = mainPhoto?.url || null;
    }

    const isVerified = Boolean(profile.isVerified || user?.isEmailVerified || user?.isPhoneVerified);

    const raw = {
      _id: profile._id,
      id: profile.userId,
      userId: profile.userId,

      role: user?.role || 'user',
      isPremium: user?.isPremium || false,
      isEmailVerified: user?.isEmailVerified || false,
      isPhoneVerified: user?.isPhoneVerified || false,
      isVerified,

      createdAt: user?.createdAt || profile.createdAt,

      profileId: profile.profileId || profile._id?.toString(),
      fullName: profile.fullName,
      age: profile.age,
      gender: profile.gender,
      city: profile.city,
      state: profile.state,
      country: profile.country,
      occupation: profile.occupation,
      education: profile.education,
      religion: profile.religion,
      caste: profile.caste,
      maritalStatus: profile.maritalStatus,
      diet: profile.diet,
      smoking: profile.smoking,
      drinking: profile.drinking,
      height: profile.height,
      weight: profile.weight,
      bodyType: profile.bodyType,
      bio: profile.bio,
      annualIncome: profile.annualIncome,

      photoUrl,
      photos: profile.photos || [],
      completionPercentage: profile.completionPercentage || 0,
      completionDetails: profile.completionDetails || {},
      lastActive: profile.lastActive,

      privacySettings: profile.privacySettings,
    };

    const isMatch = matchSet.has(profile.userId?.toString());
    const safe = applyProfilePrivacy({ viewer, profile: raw, isMatch });
    delete safe.privacySettings;
    if (safe.photosLocked) safe.photoUrl = null;
    return safe;
  });
};

// Controllers unchanged below...
export const searchProfiles = async (req, res) => {
  try {
    const viewer = req.user;
    const userId = viewer._id;

    const { page, limit, skip } = parsePagination(req.query, {
      maxLimit: LIMITS.MAX_LIMIT_SEARCH,
    });

    const {
      gender,
      minAge,
      maxAge,
      religion,
      caste,
      city,
      state,
      country,
      education,
      occupation,
      maritalStatus,
      diet,
      smoking,
      drinking,
      sortBy = 'createdAt',
      sortOrder = 'desc',
    } = req.query;

    const query = { userId: { $ne: userId } };

    if (gender && gender !== 'all') query.gender = gender;

    if (minAge || maxAge) {
      query.age = {};
      if (minAge) query.age.$gte = parseInt(minAge, 10);
      if (maxAge) query.age.$lte = parseInt(maxAge, 10);
    }

    if (religion && religion !== '') query.religion = { $regex: escapeRegex(religion), $options: 'i' };
    if (caste && caste !== '') query.caste = { $regex: escapeRegex(caste), $options: 'i' };
    if (city && city !== '') query.city = { $regex: escapeRegex(city), $options: 'i' };
    if (state && state !== '') query.state = { $regex: escapeRegex(state), $options: 'i' };
    if (country && country !== '') query.country = { $regex: escapeRegex(country), $options: 'i' };
    if (occupation && occupation !== '') query.occupation = { $regex: escapeRegex(occupation), $options: 'i' };

    if (education && education !== '') query.education = education;
    if (maritalStatus && maritalStatus !== '') query.maritalStatus = maritalStatus;
    if (diet && diet !== '') query.diet = diet;
    if (smoking && smoking !== '') query.smoking = smoking;
    if (drinking && drinking !== '') query.drinking = drinking;

    const allowedSortFields = ['createdAt', 'age', 'completionPercentage', 'lastActive'];
    const sortField = allowedSortFields.includes(sortBy) ? sortBy : 'createdAt';
    const sort = { [sortField]: sortOrder === 'asc' ? 1 : -1 };

    const [profiles, total] = await Promise.all([
      Profile.find(query)
        .sort(sort)
        .skip(skip)
        .limit(limit)
        .select('-partnerPreferences')
        .lean(),
      Profile.countDocuments(query),
    ]);

    const formattedProfiles = await formatProfilesWithUserData(profiles, viewer);

    res.json({
      success: true,
      profiles: formattedProfiles,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Search profiles');
  }
};

export const quickSearch = async (req, res) => {
  try {
    const viewer = req.user;
    const userId = viewer._id;

    const { page, limit, skip } = parsePagination(req.query, {
      maxLimit: LIMITS.MAX_LIMIT_SEARCH,
      defaultLimit: 12,
    });

    const { gender, minAge, maxAge, religion, city } = req.query;

    const query = { userId: { $ne: userId } };

    if (gender && gender !== 'all') query.gender = gender;

    if (minAge || maxAge) {
      query.age = {};
      if (minAge) query.age.$gte = parseInt(minAge, 10);
      if (maxAge) query.age.$lte = parseInt(maxAge, 10);
    }

    if (religion && religion !== '') query.religion = { $regex: escapeRegex(religion), $options: 'i' };
    if (city && city !== '') query.city = { $regex: escapeRegex(city), $options: 'i' };

    const [profiles, total] = await Promise.all([
      Profile.find(query)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .select('-partnerPreferences')
        .lean(),
      Profile.countDocuments(query),
    ]);

    const formattedProfiles = await formatProfilesWithUserData(profiles, viewer);

    res.json({
      success: true,
      profiles: formattedProfiles,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Quick search');
  }
};

export const getSuggestedProfiles = async (req, res) => {
  try {
    const viewer = req.user;
    const userId = viewer._id;
    const limitNum = Math.min(50, Math.max(1, parseInt(req.query.limit, 10) || 10));

    const profiles = await Profile.find({ userId: { $ne: userId } })
      .sort({ createdAt: -1 })
      .limit(limitNum)
      .select('-partnerPreferences')
      .lean();

    const formattedProfiles = await formatProfilesWithUserData(profiles, viewer);

    res.json({ success: true, profiles: formattedProfiles });
  } catch (e) {
    handleControllerError(res, e, 'Get suggested profiles');
  }
};

export const getRecentProfiles = async (req, res) => {
  try {
    const viewer = req.user;
    const userId = viewer._id;
    const limitNum = Math.min(50, Math.max(1, parseInt(req.query.limit, 10) || 10));

    const profiles = await Profile.find({ userId: { $ne: userId } })
      .sort({ createdAt: -1 })
      .limit(limitNum)
      .select('-partnerPreferences')
      .lean();

    const formattedProfiles = await formatProfilesWithUserData(profiles, viewer);

    res.json({ success: true, profiles: formattedProfiles });
  } catch (e) {
    handleControllerError(res, e, 'Get recent profiles');
  }
};

export const searchById = async (req, res) => {
  try {
    const viewer = req.user;
    const { profileId } = req.params;

    let profile = await Profile.findOne({ profileId }).lean();

    if (!profile && /^[0-9a-fA-F]{24}$/.test(profileId)) {
      profile = await Profile.findById(profileId).lean();
    }

    if (!profile) {
      return res.status(404).json({ success: false, message: 'Profile not found' });
    }

    const formattedProfile = await formatProfileWithUserData(profile, viewer);

    return res.json({ success: true, profile: formattedProfile });
  } catch (e) {
    handleControllerError(res, e, 'Search by ID');
  }
};

export const getFilterOptions = async (req, res) => {
  try {
    const [religions, cities, educations] = await Promise.all([
      Profile.distinct('religion'),
      Profile.distinct('city'),
      Profile.distinct('education'),
    ]);

    res.json({
      success: true,
      religions: religions.filter(Boolean).sort(),
      cities: cities.filter(Boolean).sort(),
      educations: educations.filter(Boolean).sort(),
      maritalStatuses: ['never_married', 'divorced', 'widowed', 'awaiting_divorce', 'annulled'],
      diets: ['vegetarian', 'non_vegetarian', 'eggetarian', 'vegan', 'jain', 'pescatarian'],
      bodyTypes: ['slim', 'average', 'athletic', 'heavy', 'fit'],
    });
  } catch (e) {
    handleControllerError(res, e, 'Get filter options');
  }
};

export default {
  searchProfiles,
  quickSearch,
  getSuggestedProfiles,
  getRecentProfiles,
  searchById,
  getFilterOptions,
};===== FILE: ./controllers/authController.js =====
// ===== FIXED FILE: ./controllers/authController.js =====
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import mongoose from 'mongoose'; // ✅ FIX: Added for transaction
import User from '../models/User.js';
import Profile from '../models/Profile.js';
import Interest from '../models/Interest.js'; // ✅ FIX: Added for cleanup
import Shortlist from '../models/Shortlist.js'; // ✅ FIX: Added for cleanup
import Notification from '../models/Notification.js'; // ✅ FIX: Added for cleanup
import Message from '../models/Message.js'; // ✅ FIX: Added for cleanup
import Conversation from '../models/Conversation.js'; // ✅ FIX: Added for cleanup
import Subscription from '../models/Subscription.js'; // ✅ FIX: Added for cleanup
import Payment from '../models/Payment.js'; // ✅ FIX: Added for cleanup
import { handleControllerError, AppError } from '../utils/errors.js';
import { TOKEN_EXPIRY } from '../utils/constants.js';

const sha256 = (data) => crypto.createHash('sha256').update(data).digest('hex');

const generateAccessToken = (user) => {
  const secret = process.env.JWT_SECRET;
  if (!secret) throw new Error('JWT_SECRET is not configured');

  return jwt.sign(
    { id: user._id, role: user.role },
    secret,
    { expiresIn: process.env.JWT_EXPIRE || TOKEN_EXPIRY.ACCESS_TOKEN }
  );
};

const generateRefreshToken = () => crypto.randomBytes(40).toString('hex');
const hashToken = (token) => sha256(token);

const getUserWithPhoto = async (user) => {
  let photoUrl = null;
  let fullName = null;
  let completionPercentage = 0;
  let completionDetails = {};
  let profileId = null;

  try {
    const profile = await Profile.findOne({ userId: user._id }).lean();

    if (profile) {
      completionPercentage = profile.completionPercentage || 0;

      if (profile.completionDetails) {
        if (profile.completionDetails instanceof Map) {
          completionDetails = Object.fromEntries(profile.completionDetails);
        } else {
          completionDetails = profile.completionDetails;
        }
      }

      if (profile.photos?.length > 0) {
        const mainPhoto = profile.photos.find((p) => p.isProfile) || profile.photos[0];
        photoUrl = mainPhoto?.url || null;
      }

      fullName = profile.fullName || null;
      profileId = profile.profileId || profile._id?.toString() || null;
    }
  } catch (err) {
    console.error('Error fetching profile for user:', err.message);
  }

  return {
    id: user._id,
    email: user.email,
    role: user.role,
    subscription: user.subscription,
    profileId,
    phone: user.phone,
    countryCode: user.countryCode,
    isPremium: user.isPremium,
    isEmailVerified: user.isEmailVerified,
    isActive: user.isActive,
    isSuspended: user.isSuspended,
    createdAt: user.createdAt,
    photoUrl,
    fullName,
    completionPercentage,
    completionDetails,
  };
};

export const register = async (req, res) => {
  try {
    const { email, password, phone, countryCode } = req.body;

    if (!email || !password) {
      return res.status(400).json({ message: 'Email and password are required' });
    }
    if (password.length < 6) {
      return res.status(400).json({ message: 'Password must be at least 6 characters' });
    }

    const normalizedEmail = email.toLowerCase();
    const existingEmail = await User.findOne({ email: normalizedEmail });
    if (existingEmail) {
      return res.status(409).json({ message: 'Email already registered' });
    }

    if (phone) {
      const existingPhone = await User.findOne({ phone });
      if (existingPhone) {
        return res.status(409).json({ message: 'Phone already registered' });
      }
    }

    // ✅ FIX: Basic countryCode validation
    const validCountryCode =
      countryCode && /^\+\d{1,4}$/.test(countryCode) ? countryCode : '+91';

    const refreshToken = generateRefreshToken();

    const user = await User.create({
      email: normalizedEmail,
      password,
      refreshToken: hashToken(refreshToken),
      phone: phone || undefined,
      countryCode: validCountryCode,
      isActive: true,
      isSuspended: false,
    });

    let token;
    try {
      token = generateAccessToken(user);
    } catch (tokenError) {
      await User.findByIdAndDelete(user._id);
      throw new AppError('Server configuration error', 500, 'CONFIG_ERROR');
    }

    const userData = await getUserWithPhoto(user);
    res.status(201).json({ user: userData, token, refreshToken });
  } catch (e) {
    if (e.code === 11000 && e.keyPattern) {
      const field = Object.keys(e.keyPattern)[0];
      return res.status(409).json({
        message: `${field.charAt(0).toUpperCase() + field.slice(1)} already registered`,
      });
    }
    handleControllerError(res, e, 'Register');
  }
};

export const login = async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ message: 'Email and password are required' });
    }

    const normalizedEmail = email.toLowerCase();
    const user = await User.findOne({ email: normalizedEmail }).select('+password');
    if (!user) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    if (user.isSuspended) {
      return res.status(403).json({
        message: 'Account suspended',
        code: 'ACCOUNT_SUSPENDED',
        reason: user.suspensionReason,
      });
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    const token = generateAccessToken(user);
    const refreshToken = generateRefreshToken();

    user.refreshToken = hashToken(refreshToken);
    user.lastLogin = new Date();
    user.isOnline = true;
    await user.save();

    const userData = await getUserWithPhoto(user);
    res.json({ user: userData, token, refreshToken });
  } catch (e) {
    handleControllerError(res, e, 'Login');
  }
};

export const sendEmailOtp = async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ message: 'Email is required' });

    const token = crypto.randomBytes(32).toString('hex');
    const expiry = new Date(Date.now() + TOKEN_EXPIRY.EMAIL_VERIFICATION);

    const user = await User.findOne({ email: email.toLowerCase() });
    if (!user) return res.status(404).json({ message: 'User not found' });

    user.emailVerificationToken = sha256(token);
    user.emailVerificationExpiry = expiry;
    await user.save();

    const response = { message: 'Verification email sent' };
    if (process.env.NODE_ENV !== 'production') response.token = token;

    res.json(response);
  } catch (e) {
    handleControllerError(res, e, 'Send email OTP');
  }
};

export const verifyEmail = async (req, res) => {
  try {
    const { token } = req.params;
    if (!token) return res.status(400).json({ message: 'Token required' });

    const user = await User.findOne({ emailVerificationToken: sha256(token) });
    if (!user) return res.status(400).json({ message: 'Invalid token' });

    if (user.emailVerificationExpiry < new Date()) {
      return res.status(400).json({ message: 'Token expired' });
    }

    user.isEmailVerified = true;
    user.emailVerificationToken = undefined;
    user.emailVerificationExpiry = undefined;
    await user.save();

    res.json({ message: 'Email verified' });
  } catch (e) {
    handleControllerError(res, e, 'Verify email');
  }
};

export const refreshToken = async (req, res) => {
  try {
    const { refreshToken: rt } = req.body;
    if (!rt) return res.status(400).json({ message: 'Refresh token required' });

    const user = await User.findOne({ refreshToken: hashToken(rt) });
    if (!user) return res.status(401).json({ message: 'Invalid refresh token' });

    const token = generateAccessToken(user);
    const newRefresh = generateRefreshToken();

    user.refreshToken = hashToken(newRefresh);
    user.lastActive = new Date();
    await user.save();

    res.json({ token, refreshToken: newRefresh });
  } catch (e) {
    handleControllerError(res, e, 'Refresh token');
  }
};

export const logout = async (req, res) => {
  try {
    const { refreshToken: rt } = req.body;

    if (rt) {
      const user = await User.findOne({ refreshToken: hashToken(rt) });
      if (user) {
        user.refreshToken = undefined;
        user.isOnline = false;
        await user.save();
      }
    }

    res.json({ message: 'Logged out' });
  } catch (e) {
    handleControllerError(res, e, 'Logout');
  }
};

export const getMe = async (req, res) => {
  try {
    const user = await User.findById(req.user._id);
    if (!user) return res.status(404).json({ message: 'User not found' });

    const userData = await getUserWithPhoto(user);
    res.json({ user: userData });
  } catch (e) {
    handleControllerError(res, e, 'Get me');
  }
};

export const forgotPassword = async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ message: 'Email required' });

    const user = await User.findOne({ email: email.toLowerCase() });
    if (!user) {
      return res.json({ message: 'If email exists, reset instructions will be sent' });
    }

    const resetToken = crypto.randomBytes(32).toString('hex');
    user.passwordResetToken = sha256(resetToken);
    user.passwordResetExpiry = new Date(Date.now() + TOKEN_EXPIRY.PASSWORD_RESET);
    await user.save();

    const response = { message: 'Reset instructions sent' };
    if (process.env.NODE_ENV !== 'production') response.resetToken = resetToken;

    res.json(response);
  } catch (e) {
    handleControllerError(res, e, 'Forgot password');
  }
};

export const resetPassword = async (req, res) => {
  try {
    const { token } = req.params;
    const { password } = req.body;

    if (!token || !password) {
      return res.status(400).json({ message: 'Token and password required' });
    }
    if (password.length < 6) {
      return res.status(400).json({ message: 'Password must be at least 6 characters' });
    }

    const user = await User.findOne({ passwordResetToken: sha256(token) }).select('+password');
    if (!user) return res.status(400).json({ message: 'Invalid token' });

    if (user.passwordResetExpiry < new Date()) {
      return res.status(400).json({ message: 'Token expired' });
    }

    user.password = password;
    user.passwordResetToken = undefined;
    user.passwordResetExpiry = undefined;
    user.refreshToken = undefined;
    await user.save();

    res.json({ message: 'Password reset successful' });
  } catch (e) {
    handleControllerError(res, e, 'Reset password');
  }
};

export const changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;

    if (!currentPassword || !newPassword) {
      return res.status(400).json({ message: 'Current and new password required' });
    }
    if (newPassword.length < 6) {
      return res.status(400).json({ message: 'New password must be at least 6 characters' });
    }

    const user = await User.findById(req.user._id).select('+password');
    if (!user) return res.status(404).json({ message: 'User not found' });

    const isMatch = await bcrypt.compare(currentPassword, user.password);
    if (!isMatch) return res.status(400).json({ message: 'Current password incorrect' });

    user.password = newPassword;
    await user.save();

    res.json({ message: 'Password changed' });
  } catch (e) {
    handleControllerError(res, e, 'Change password');
  }
};

// ✅ FIX: Full cleanup with transaction — no orphaned data
export const deleteAccount = async (req, res) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const { password } = req.body;
    const userId = req.user._id;

    const user = await User.findById(userId).select('+password').session(session);
    if (!user) {
      await session.abortTransaction();
      return res.status(404).json({ message: 'User not found' });
    }
    if (!password) {
      await session.abortTransaction();
      return res.status(400).json({ message: 'Password confirmation required' });
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      await session.abortTransaction();
      return res.status(400).json({ message: 'Invalid password' });
    }

    // ✅ FIX: Clean up ALL related data atomically
    await Profile.deleteOne({ userId }).session(session);
    await Interest.deleteMany({
      $or: [{ senderId: userId }, { receiverId: userId }],
    }).session(session);
    await Shortlist.deleteMany({
      $or: [{ userId }, { shortlistedUserId: userId }],
    }).session(session);
    await Notification.deleteMany({ userId }).session(session);
    await Message.updateMany(
      { $or: [{ senderId: userId }, { receiverId: userId }] },
      { isDeleted: true, deletedAt: new Date() }
    ).session(session);
    await Subscription.deleteOne({ userId }).session(session);
    await Payment.deleteMany({ userId }).session(session);

    // Remove user from conversations (soft: mark messages deleted, remove participant)
    const userConversations = await Conversation.find({ participants: userId })
      .select('_id')
      .session(session);
    for (const conv of userConversations) {
      await Message.updateMany(
        { conversationId: conv._id },
        { isDeleted: true, deletedAt: new Date() }
      ).session(session);
    }
    await Conversation.deleteMany({
      participants: userId,
    }).session(session);

    await User.findByIdAndDelete(userId).session(session);

    await session.commitTransaction();

    res.json({ message: 'Account deleted' });
  } catch (e) {
    await session.abortTransaction();
    handleControllerError(res, e, 'Delete account');
  } finally {
    session.endSession();
  }
};===== FILE: ./controllers/subscriptionController.js =====
// ===== FILE: ./controllers/subscriptionController.js =====
import Stripe from 'stripe';
import Subscription from '../models/Subscription.js';
import Payment from '../models/Payment.js';
import User from '../models/User.js';
import { handleControllerError } from '../utils/errors.js';
import {
  getCurrencyFromCountryCode,
  getPricesInCurrency,
  getStripeCurrency,
  convertPrice,
  basePricesUSD,
  toMinorUnits,
  toMajorUnits,
} from '../utils/currency.js';

/**
 * IMPORTANT FIX:
 * Do NOT initialize Stripe using process.env at module import time.
 * If dotenv loads after this file is imported, the key will be undefined and Stripe will stay null.
 *
 * We lazily create the Stripe client at runtime and cache it.
 */
let stripeClient = null;
let stripeInitLogged = false;

const getStripeClient = () => {
  const key = process.env.STRIPE_SECRET_KEY;

  if (!key) {
    if (process.env.NODE_ENV === 'production') {
      throw new Error('STRIPE_SECRET_KEY is required in production');
    }
    return null;
  }

  if (stripeClient) return stripeClient;

  stripeClient = new Stripe(key, {
    apiVersion: '2024-06-20',
  });

  if (!stripeInitLogged) {
    console.log('✅ Stripe initialized');
    stripeInitLogged = true;
  }

  return stripeClient;
};

const requireStripe = (res) => {
  let stripe;
  try {
    stripe = getStripeClient();
  } catch (e) {
    res.status(500).json({
      message: 'Payment system misconfigured',
      code: 'PAYMENT_MISCONFIGURED',
      hint: e.message,
    });
    return null;
  }

  if (!stripe) {
    res.status(503).json({
      message: 'Payment system not configured',
      code: 'PAYMENT_NOT_CONFIGURED',
      hint: 'Set STRIPE_SECRET_KEY in backend .env and restart the server',
    });
    return null;
  }
  return stripe;
};

const PLAN_CONFIG = {
  free: {
    name: 'Free',
    interval: null,
    features: ['Create Profile', 'Basic Search', 'Send 5 Interests/day', 'Limited Messaging'],
  },
  monthly: {
    name: 'Premium Monthly',
    interval: 'month',
    intervalCount: 1,
    features: ['Unlimited Messages', 'See Who Liked You', 'Advanced Filters', 'Unlimited Interests', 'Read Receipts', 'No Ads'],
  },
  yearly: {
    name: 'Premium Yearly',
    interval: 'year',
    intervalCount: 1,
    features: ['All Monthly Features', 'Priority Support', 'Profile Boost', '2 Months Free', 'Exclusive Badge'],
  },
};

const FREE_FEATURES = {
  unlimitedMessages: false,
  seeWhoLikedYou: false,
  advancedFilters: false,
  prioritySupport: false,
  profileBoost: false,
  unlimitedLikes: false,
  readReceipts: false,
  noAds: false,
};

const getPremiumFeatures = (plan) => ({
  unlimitedMessages: true,
  seeWhoLikedYou: true,
  advancedFilters: true,
  prioritySupport: plan === 'yearly',
  profileBoost: plan === 'yearly',
  unlimitedLikes: true,
  readReceipts: true,
  noAds: true,
});

const getStripePeriodFromSubscriptionId = async (stripeSubscriptionId, stripe = null) => {
  const s = stripe || getStripeClient();
  if (!s || !stripeSubscriptionId) return null;

  try {
    const sub = await s.subscriptions.retrieve(stripeSubscriptionId);
    return {
      startDate: sub.current_period_start ? new Date(sub.current_period_start * 1000) : null,
      endDate: sub.current_period_end ? new Date(sub.current_period_end * 1000) : null,
      status: sub.status,
      cancelAtPeriodEnd: Boolean(sub.cancel_at_period_end),
    };
  } catch {
    return null;
  }
};

const computeLocalPeriod = (planId) => {
  const startDate = new Date();
  const endDate = new Date();
  if (planId === 'yearly') endDate.setFullYear(endDate.getFullYear() + 1);
  else endDate.setMonth(endDate.getMonth() + 1);
  return { startDate, endDate };
};

const getChargePricing = ({ planId, countryCurrency }) => {
  const desired = String(countryCurrency || 'USD').toUpperCase();
  const stripeCurrency = getStripeCurrency(desired);
  const chargeCurrency = stripeCurrency.toUpperCase();

  const usd = basePricesUSD[planId];
  const amountMajor = chargeCurrency === 'USD' ? usd : convertPrice(usd, chargeCurrency);
  const amountMinor = toMinorUnits(amountMajor, chargeCurrency);

  return { stripeCurrency, chargeCurrency, amountMajor, amountMinor };
};

// PUBLIC
export const getPlans = async (req, res) => {
  try {
    let countryCode = '+1';

    if (req.user?._id) {
      const user = await User.findById(req.user._id).select('countryCode').lean();
      countryCode = user?.countryCode || countryCode;
    } else if (req.query.countryCode) {
      countryCode = String(req.query.countryCode);
    }

    const currencyInfo = getCurrencyFromCountryCode(countryCode);
    const prices = getPricesInCurrency(currencyInfo.currency);

    const stripeConfigured = Boolean(process.env.STRIPE_SECRET_KEY);

    res.json({
      plans: [
        {
          id: 'free',
          name: PLAN_CONFIG.free.name,
          price: 0,
          displayPrice: `${prices.symbol}0`,
          currency: prices.currency,
          symbol: prices.symbol,
          interval: null,
          features: PLAN_CONFIG.free.features,
          recommended: false,
        },
        {
          id: 'monthly',
          name: PLAN_CONFIG.monthly.name,
          price: prices.monthly.price,
          displayPrice: prices.monthly.display,
          currency: prices.currency,
          symbol: prices.symbol,
          interval: 'month',
          features: PLAN_CONFIG.monthly.features,
          recommended: false,
        },
        {
          id: 'yearly',
          name: PLAN_CONFIG.yearly.name,
          price: prices.yearly.price,
          displayPrice: prices.yearly.display,
          pricePerMonth: Math.round((prices.yearly.price / 12) * 100) / 100,
          currency: prices.currency,
          symbol: prices.symbol,
          interval: 'year',
          features: PLAN_CONFIG.yearly.features,
          savings: prices.yearly.savings,
          recommended: true,
        },
      ],
      currency: prices.currency,
      symbol: prices.symbol,
      country: currencyInfo.country,
      stripeConfigured,
    });
  } catch (e) {
    handleControllerError(res, e, 'Get plans');
  }
};

// PROTECTED
export const getMySubscription = async (req, res) => {
  try {
    const subscription = await Subscription.findOneAndUpdate(
      { userId: req.user._id },
      { $setOnInsert: { plan: 'free', status: 'active', features: FREE_FEATURES, startDate: new Date() } },
      { upsert: true, new: true, setDefaultsOnInsert: true }
    );

    await User.findByIdAndUpdate(req.user._id, {
      subscriptionId: subscription._id,
      'subscription.plan': subscription.plan || 'free',
      'subscription.startDate': subscription.startDate || undefined,
      'subscription.endDate': subscription.endDate || undefined,
      'subscription.isActive': subscription.isActive(),
      premiumExpiry: subscription.endDate || undefined,
    });

    const user = await User.findById(req.user._id).select('countryCode').lean();
    const countryCode = user?.countryCode || '+1';
    const currencyInfo = getCurrencyFromCountryCode(countryCode);
    const prices = getPricesInCurrency(currencyInfo.currency);

    res.json({
      subscription: { ...subscription.toObject(), isActive: subscription.isActive(), planConfig: PLAN_CONFIG[subscription.plan] },
      prices,
    });
  } catch (e) {
    handleControllerError(res, e, 'Get subscription');
  }
};

export const createCheckoutSession = async (req, res) => {
  try {
    const stripe = requireStripe(res);
    if (!stripe) return;

    const { planId } = req.body;
    const userId = req.user._id;
    if (!planId || !['monthly', 'yearly'].includes(planId)) return res.status(400).json({ message: 'Invalid plan' });

    const user = await User.findById(userId).select('email phone countryCode').lean();
    const currencyInfo = getCurrencyFromCountryCode(user?.countryCode || '+1');

    const { stripeCurrency, chargeCurrency, amountMajor, amountMinor } = getChargePricing({
      planId,
      countryCurrency: currencyInfo.currency,
    });

    const subDoc = await Subscription.findOneAndUpdate(
      { userId },
      { $setOnInsert: { plan: 'free', status: 'active', features: FREE_FEATURES } },
      { upsert: true, new: true }
    );

    let customerId = subDoc.stripeCustomerId;
    if (!customerId) {
      const customer = await stripe.customers.create({
        email: user.email,
        phone: user.phone ? `${user.countryCode}${user.phone}` : undefined,
        metadata: { userId: userId.toString() },
      });
      customerId = customer.id;
      await Subscription.findByIdAndUpdate(subDoc._id, { stripeCustomerId: customerId });
    }

    if (!process.env.CLIENT_URL) {
      return res.status(500).json({
        message: 'CLIENT_URL not configured',
        code: 'CLIENT_URL_MISSING',
        hint: 'Set CLIENT_URL in backend .env (e.g. http://localhost:5173)',
      });
    }

    const session = await stripe.checkout.sessions.create({
      customer: customerId,
      payment_method_types: ['card'],
      line_items: [
        {
          price_data: {
            currency: stripeCurrency,
            product_data: {
              name: PLAN_CONFIG[planId].name,
              description: `Matrimony ${planId === 'yearly' ? 'Annual' : 'Monthly'} Premium`,
            },
            unit_amount: amountMinor,
            recurring: { interval: planId === 'yearly' ? 'year' : 'month', interval_count: 1 },
          },
          quantity: 1,
        },
      ],
      mode: 'subscription',
      success_url: `${process.env.CLIENT_URL}/subscription/success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.CLIENT_URL}/pricing?cancelled=true`,
      metadata: { userId: userId.toString(), planId, currency: chargeCurrency },
    });

    await Subscription.findByIdAndUpdate(subDoc._id, { currency: chargeCurrency, amount: amountMajor });

    res.json({ sessionId: session.id, url: session.url, currency: chargeCurrency, amount: amountMajor });
  } catch (e) {
    handleControllerError(res, e, 'Create checkout session');
  }
};

export const createPaymentIntent = async (req, res) => {
  try {
    const stripe = requireStripe(res);
    if (!stripe) return;

    const { planId } = req.body;
    const userId = req.user._id;
    if (!planId || !['monthly', 'yearly'].includes(planId)) return res.status(400).json({ message: 'Invalid plan' });

    const user = await User.findById(userId).select('email countryCode').lean();
    const currencyInfo = getCurrencyFromCountryCode(user?.countryCode || '+1');

    const { stripeCurrency, chargeCurrency, amountMajor, amountMinor } = getChargePricing({
      planId,
      countryCurrency: currencyInfo.currency,
    });

    const subDoc = await Subscription.findOneAndUpdate(
      { userId },
      { $setOnInsert: { plan: 'free', status: 'active', features: FREE_FEATURES } },
      { upsert: true, new: true }
    );

    let customerId = subDoc.stripeCustomerId;
    if (!customerId) {
      const customer = await stripe.customers.create({ email: user.email, metadata: { userId: userId.toString() } });
      customerId = customer.id;
      await Subscription.findByIdAndUpdate(subDoc._id, { stripeCustomerId: customerId });
    }

    const paymentIntent = await stripe.paymentIntents.create({
      amount: amountMinor,
      currency: stripeCurrency,
      customer: customerId,
      metadata: { userId: userId.toString(), planId, currency: chargeCurrency },
      automatic_payment_methods: { enabled: true },
    });

    await Payment.create({
      userId,
      subscriptionId: subDoc._id,
      stripePaymentIntentId: paymentIntent.id,
      amount: amountMajor,
      amountMinor,
      currency: chargeCurrency,
      plan: planId,
      status: 'pending',
    });

    res.json({
      clientSecret: paymentIntent.client_secret,
      paymentIntentId: paymentIntent.id,
      amount: amountMajor,
      currency: chargeCurrency,
      symbol: currencyInfo.symbol,
    });
  } catch (e) {
    handleControllerError(res, e, 'Create payment intent');
  }
};

export const verifyPayment = async (req, res) => {
  try {
    const stripe = requireStripe(res);
    if (!stripe) return;

    const { paymentIntentId, sessionId } = req.body;
    const userId = req.user._id;
    const expectedUserId = userId.toString();

    let planId;
    let customerId;
    let stripeSubscriptionId;
    let chargeCurrency;

    if (sessionId) {
      const session = await stripe.checkout.sessions.retrieve(sessionId);

      if (session.payment_status !== 'paid' && session.payment_status !== 'no_payment_required') {
        return res.status(400).json({ message: 'Payment not completed' });
      }

      if (!session.metadata?.userId || session.metadata.userId !== expectedUserId) {
        return res.status(403).json({ message: 'Session does not belong to user' });
      }

      planId = session.metadata?.planId;
      if (!planId) return res.status(400).json({ message: 'Missing plan in session metadata' });

      customerId = session.customer;
      stripeSubscriptionId = session.subscription || undefined;
      chargeCurrency = (session.metadata?.currency || session.currency || 'USD').toUpperCase();
    } else if (paymentIntentId) {
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);

      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({ message: 'Payment not successful' });
      }

      if (!paymentIntent.metadata?.userId || paymentIntent.metadata.userId !== expectedUserId) {
        return res.status(403).json({ message: 'Payment does not belong to user' });
      }

      planId = paymentIntent.metadata?.planId;
      if (!planId) return res.status(400).json({ message: 'Missing plan in payment metadata' });

      customerId = paymentIntent.customer;
      chargeCurrency = (paymentIntent.metadata?.currency || paymentIntent.currency || 'USD').toUpperCase();

      await Payment.findOneAndUpdate(
        { stripePaymentIntentId: paymentIntentId },
        { status: 'succeeded', stripeChargeId: paymentIntent.latest_charge }
      );
    } else {
      return res.status(400).json({ message: 'Payment ID required' });
    }

    if (!planId || !['monthly', 'yearly'].includes(planId)) {
      return res.status(400).json({ message: 'Invalid plan in payment metadata' });
    }

    const subDoc = await Subscription.findOne({ userId }).select('stripeCustomerId').lean();
    if (subDoc?.stripeCustomerId && customerId && subDoc.stripeCustomerId !== customerId) {
      return res.status(403).json({ message: 'Payment customer mismatch' });
    }

    const stripePeriod = await getStripePeriodFromSubscriptionId(stripeSubscriptionId, stripe);
    const localPeriod = computeLocalPeriod(planId);

    const startDate = stripePeriod?.startDate || localPeriod.startDate;
    const endDate = stripePeriod?.endDate || localPeriod.endDate;

    const subscription = await Subscription.findOneAndUpdate(
      { userId },
      {
        plan: planId,
        status: 'active',
        stripeCustomerId: customerId,
        stripeSubscriptionId: stripeSubscriptionId || undefined,
        startDate,
        endDate,
        autoRenew: Boolean(stripeSubscriptionId),
        currency: chargeCurrency || 'USD',
        features: getPremiumFeatures(planId),
      },
      { upsert: true, new: true }
    );

    await User.findByIdAndUpdate(userId, {
      isPremium: true,
      premiumExpiry: endDate,
      subscriptionId: subscription._id,
      'subscription.plan': planId,
      'subscription.startDate': startDate,
      'subscription.endDate': endDate,
      'subscription.isActive': true,
    });

    res.json({ message: 'Subscription activated', subscription: { ...subscription.toObject(), isActive: true } });
  } catch (e) {
    handleControllerError(res, e, 'Verify payment');
  }
};

export const cancelSubscription = async (req, res) => {
  try {
    const userId = req.user._id;
    const { reason } = req.body;

    const subscription = await Subscription.findOne({ userId });
    if (!subscription || subscription.plan === 'free') return res.status(400).json({ message: 'No active subscription' });

    const stripe = getStripeClient();
    if (subscription.stripeSubscriptionId && stripe) {
      try {
        await stripe.subscriptions.update(subscription.stripeSubscriptionId, { cancel_at_period_end: true });
      } catch (stripeError) {
        console.error('Stripe cancel error:', stripeError?.message);
      }
    }

    subscription.status = 'active';
    subscription.cancelledAt = new Date();
    subscription.autoRenew = false;
    await subscription.save();

    if (reason) console.log(`Subscription cancelled for user ${userId}: ${reason}`);

    await User.findByIdAndUpdate(userId, {
      premiumExpiry: subscription.endDate || undefined,
      'subscription.isActive': subscription.isActive(),
    });

    res.json({ message: 'Subscription cancelled. Access continues until end of billing period.', subscription });
  } catch (e) {
    handleControllerError(res, e, 'Cancel subscription');
  }
};

export const getPaymentHistory = async (req, res) => {
  try {
    const userId = req.user._id;
    const pageNum = Math.max(1, parseInt(req.query.page || '1', 10));
    const limitNum = Math.min(100, Math.max(1, parseInt(req.query.limit || '10', 10)));

    const total = await Payment.countDocuments({ userId, status: 'succeeded' });
    const payments = await Payment.find({ userId, status: 'succeeded' })
      .sort({ createdAt: -1 })
      .skip((pageNum - 1) * limitNum)
      .limit(limitNum)
      .lean();

    res.json({ payments, pagination: { page: pageNum, limit: limitNum, total, pages: Math.ceil(total / limitNum) } });
  } catch (e) {
    handleControllerError(res, e, 'Get payment history');
  }
};

export const checkFeatureAccess = async (req, res) => {
  try {
    const { feature } = req.params;
    const userId = req.user._id;

    const subscription = await Subscription.findOne({ userId });
    if (!subscription) return res.json({ hasAccess: false, plan: 'free' });

    const isActive = subscription.isActive();
    const hasFeature = subscription.features?.[feature] || false;

    res.json({ hasAccess: isActive && hasFeature, plan: subscription.plan, isActive });
  } catch (e) {
    handleControllerError(res, e, 'Check feature access');
  }
};

export const handleWebhook = async (req, res) => {
  const stripe = getStripeClient();
  if (!stripe) return res.status(503).json({ error: 'Stripe not configured' });

  const sig = req.headers['stripe-signature'];
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
  if (!webhookSecret) return res.status(500).json({ error: 'STRIPE_WEBHOOK_SECRET not configured' });

  let event;
  try {
    if (!req.rawBody) return res.status(400).json({ error: 'Missing raw body for webhook verification' });
    event = stripe.webhooks.constructEvent(req.rawBody, sig, webhookSecret);
  } catch (err) {
    console.error('Webhook signature verification failed:', err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  try {
    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object;
        const userId = session.metadata?.userId;
        const planId = session.metadata?.planId;
        const currency = (session.metadata?.currency || session.currency || 'USD').toUpperCase();

        if (userId && planId) {
          const stripeSubscriptionId = session.subscription || undefined;
          const stripePeriod = await getStripePeriodFromSubscriptionId(stripeSubscriptionId, stripe);
          const localPeriod = computeLocalPeriod(planId);

          const startDate = stripePeriod?.startDate || localPeriod.startDate;
          const endDate = stripePeriod?.endDate || localPeriod.endDate;

          const sub = await Subscription.findOneAndUpdate(
            { userId },
            {
              plan: planId,
              status: 'active',
              stripeCustomerId: session.customer,
              stripeSubscriptionId,
              startDate,
              endDate,
              autoRenew: true,
              currency,
              features: getPremiumFeatures(planId),
            },
            { upsert: true, new: true }
          );

          await User.findByIdAndUpdate(userId, {
            isPremium: true,
            premiumExpiry: endDate,
            subscriptionId: sub._id,
            'subscription.isActive': true,
            'subscription.plan': planId,
            'subscription.startDate': startDate,
            'subscription.endDate': endDate,
          });
        }
        break;
      }

      case 'customer.subscription.updated': {
        const s = event.data.object;
        const customerId = s.customer;

        const sub = await Subscription.findOne({ stripeCustomerId: customerId });
        if (sub) {
          sub.autoRenew = !s.cancel_at_period_end;
          if (s.cancel_at_period_end && !sub.cancelledAt) sub.cancelledAt = new Date();
          if (s.current_period_end) sub.endDate = new Date(s.current_period_end * 1000);

          if (s.status === 'past_due') sub.status = 'past_due';
          if (s.status === 'canceled') sub.status = 'cancelled';
          if (s.status === 'active' || s.status === 'trialing') sub.status = 'active';

          await sub.save();
          await User.findByIdAndUpdate(sub.userId, {
            premiumExpiry: sub.endDate || undefined,
            'subscription.isActive': sub.isActive(),
            'subscription.endDate': sub.endDate || undefined,
          });
        }
        break;
      }

      case 'invoice.paid': {
        const invoice = event.data.object;
        const customerId = invoice.customer;

        const subscription = await Subscription.findOne({ stripeCustomerId: customerId });
        if (subscription) {
          const line = invoice.lines?.data?.[0];
          const endDate = line?.period?.end ? new Date(line.period.end * 1000) : subscription.endDate;

          if (endDate) subscription.endDate = endDate;
          subscription.status = 'active';
          subscription.currency = String(invoice.currency || subscription.currency || 'USD').toUpperCase();
          subscription.features = getPremiumFeatures(subscription.plan);
          await subscription.save();

          await User.findByIdAndUpdate(subscription.userId, {
            isPremium: true,
            premiumExpiry: subscription.endDate || undefined,
            'subscription.isActive': true,
            'subscription.plan': subscription.plan,
            'subscription.endDate': subscription.endDate || undefined,
          });

          const currency = String(invoice.currency || 'USD').toUpperCase();
          const amountMajor = toMajorUnits(invoice.amount_paid, currency);

          await Payment.create({
            userId: subscription.userId,
            subscriptionId: subscription._id,
            stripeInvoiceId: invoice.id,
            stripeChargeId: invoice.charge,
            amount: amountMajor,
            amountMinor: invoice.amount_paid,
            currency,
            plan: subscription.plan,
            status: 'succeeded',
          });
        }
        break;
      }

      case 'invoice.payment_failed': {
        const invoice = event.data.object;
        const customerId = invoice.customer;

        const sub = await Subscription.findOneAndUpdate(
          { stripeCustomerId: customerId },
          { status: 'past_due' },
          { new: true }
        );

        if (sub) {
          await User.findByIdAndUpdate(sub.userId, { 'subscription.isActive': false });
        }
        break;
      }

      case 'customer.subscription.deleted': {
        const stripeSub = event.data.object;
        const customerId = stripeSub.customer;

        const subscription = await Subscription.findOne({ stripeCustomerId: customerId });
        if (subscription) {
          subscription.plan = 'free';
          subscription.status = 'cancelled';
          subscription.features = FREE_FEATURES;
          subscription.autoRenew = false;
          await subscription.save();

          await User.findByIdAndUpdate(subscription.userId, {
            isPremium: false,
            premiumExpiry: null,
            'subscription.isActive': false,
            'subscription.plan': 'free',
          });
        }
        break;
      }

      default:
        break;
    }
  } catch (e) {
    console.error('Webhook handler error:', e.message);
  }

  res.json({ received: true });
};===== FILE: ./controllers/paymentController.js =====
// ===== FILE: ./controllers/paymentController.js =====

import mongoose from 'mongoose';
import Payment from '../models/Payment.js';
import User from '../models/User.js';
import Profile from '../models/Profile.js';
import { handleControllerError } from '../utils/errors.js';
import { parsePagination, formatPaginationResponse } from '../utils/pagination.js';
import { hasPremiumAccess } from '../utils/entitlements.js';

// Helper to check if user has unlocked a contact
const hasUnlocked = (user, targetUserId) =>
  user.contactsUnlocked?.some((id) => id.toString() === targetUserId.toString());

// Unlock contact
export const unlockContact = async (req, res) => {
  try {
    const userId = req.user._id;
    const targetUserId = req.params.targetUserId || req.body.targetUserId;
    const { amount = 99 } = req.body;

    if (!targetUserId) return res.status(400).json({ message: 'Target user ID is required' });
    if (!mongoose.Types.ObjectId.isValid(targetUserId)) {
      return res.status(400).json({ message: 'Invalid target user ID' });
    }
    if (userId.toString() === targetUserId.toString()) {
      return res.status(400).json({ message: 'Cannot unlock your own contact' });
    }

    const targetUser = await User.findById(targetUserId).select('_id');
    if (!targetUser) return res.status(404).json({ message: 'User not found' });

    const user = await User.findById(userId).select('contactsUnlocked isPremium subscription premiumExpiry');
    if (!user) return res.status(404).json({ message: 'User not found' });

    if (hasUnlocked(user, targetUserId)) {
      return res.status(400).json({ message: 'Contact already unlocked', code: 'ALREADY_UNLOCKED' });
    }

    // Premium users get free unlocks (using correct entitlement logic)
    if (hasPremiumAccess(user)) {
      await User.findByIdAndUpdate(userId, { $addToSet: { contactsUnlocked: targetUserId } });
      return res.json({
        message: 'Contact unlocked (premium benefit)',
        isPremiumUnlock: true,
        targetUserId,
      });
    }

    // 🚨 In production, do not fake-success payments
    const allowMockPayments =
      process.env.NODE_ENV !== 'production' || process.env.ALLOW_MOCK_PAYMENTS === 'true';

    if (!allowMockPayments) {
      return res.status(501).json({
        message: 'Contact unlock payment is not configured',
        code: 'PAYMENT_NOT_CONFIGURED',
        hint: 'Implement and verify a real payment gateway/webhook for contact unlocks.',
      });
    }

    const cleanAmount = Math.max(0, Number(amount) || 0);

    // DEV/Mock payment record
    const payment = await Payment.create({
      userId,
      amount: cleanAmount,
      currency: 'INR',
      plan: 'contact_unlock',
      status: 'succeeded',
      description: 'Contact unlock (mock/dev)',
      metadata: {
        targetUserId,
        gateway: 'mock',
      },
    });

    await User.findByIdAndUpdate(userId, {
      $addToSet: { contactsUnlocked: targetUserId },
    });

    res.status(201).json({
      message: 'Contact unlocked successfully',
      payment: {
        _id: payment._id,
        amount: payment.amount,
        currency: payment.currency,
        status: payment.status,
      },
      targetUserId,
    });
  } catch (e) {
    handleControllerError(res, e, 'Unlock contact');
  }
};

// Check if contact is unlocked
export const isContactUnlocked = async (req, res) => {
  try {
    const userId = req.user._id;
    const { targetUserId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(targetUserId)) {
      return res.status(400).json({ message: 'Invalid target user ID' });
    }

    const user = await User.findById(userId).select('contactsUnlocked isPremium subscription premiumExpiry');
    if (!user) return res.status(404).json({ message: 'User not found' });

    const premium = hasPremiumAccess(user);
    const isUnlocked = hasUnlocked(user, targetUserId) || premium;

    res.json({
      isUnlocked,
      targetUserId,
      isPremium: premium,
      reason: premium ? 'premium' : isUnlocked ? 'purchased' : 'locked',
    });
  } catch (e) {
    handleControllerError(res, e, 'Check contact unlocked');
  }
};

// Get all unlocked contacts
export const getUnlockedContacts = async (req, res) => {
  try {
    const userId = req.user._id;
    const { page, limit, skip } = parsePagination(req.query, { maxLimit: 50 });

    const user = await User.findById(userId).select('contactsUnlocked').lean();
    if (!user) return res.status(404).json({ message: 'User not found' });

    const allIds = user.contactsUnlocked || [];
    const total = allIds.length;

    // ✅ FIX: Paginate the IDs first, then query only those
    const pageIds = allIds.slice(skip, skip + limit);

    const contacts = await User.find({ _id: { $in: pageIds } })
      .select('email phone countryCode')
      .lean();

    const enriched = await Promise.all(
      contacts.map(async (contact) => {
        const profile = await Profile.findOne({ userId: contact._id })
          .select('fullName photos')
          .lean();

        return {
          _id: contact._id,
          email: contact.email,
          phone: contact.phone,
          countryCode: contact.countryCode,
          profile: profile
            ? {
                fullName: profile.fullName,
                photoUrl:
                  profile.photos?.find((p) => p.isProfile)?.url ||
                  profile.photos?.[0]?.url ||
                  null,
              }
            : null,
        };
      })
    );

    res.json({
      contacts: enriched,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get unlocked contacts');
  }
};

// Get contact details (requires unlock or premium)
export const getContactDetails = async (req, res) => {
  try {
    const userId = req.user._id;
    const { targetUserId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(targetUserId)) {
      return res.status(400).json({ message: 'Invalid target user ID' });
    }

    const user = await User.findById(userId).select('contactsUnlocked isPremium subscription premiumExpiry');
    if (!user) return res.status(404).json({ message: 'User not found' });

    const premium = hasPremiumAccess(user);
    const isUnlocked = hasUnlocked(user, targetUserId) || premium;

    if (!isUnlocked) {
      return res.status(403).json({
        message: 'Contact not unlocked. Purchase unlock or upgrade to premium.',
        code: 'CONTACT_LOCKED',
        isPremium: false,
      });
    }

    const targetUser = await User.findById(targetUserId).select('email phone countryCode');
    if (!targetUser) return res.status(404).json({ message: 'User not found' });

    const profile = await Profile.findOne({ userId: targetUserId }).select('fullName photos').lean();

    res.json({
      contact: {
        email: targetUser.email,
        phone: targetUser.phone,
        countryCode: targetUser.countryCode,
        fullPhone: targetUser.phone ? `${targetUser.countryCode || ''}${targetUser.phone}` : null,
        fullName: profile?.fullName,
        photoUrl: profile?.photos?.find((p) => p.isProfile)?.url || profile?.photos?.[0]?.url || null,
      },
    });
  } catch (e) {
    handleControllerError(res, e, 'Get contact details');
  }
};

// Get payment history
export const getPaymentHistory = async (req, res) => {
  try {
    const userId = req.user._id;
    const { page, limit, skip } = parsePagination(req.query);
    const { status = 'all', plan = 'all' } = req.query;

    const filter = { userId };
    if (status !== 'all') filter.status = status;
    if (plan !== 'all') filter.plan = plan;

    const [payments, total] = await Promise.all([
      Payment.find(filter)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .select('-metadata.gateway')
        .lean(),
      Payment.countDocuments(filter),
    ]);

    res.json({
      payments,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get payment history');
  }
};

// Get payment by ID
export const getPaymentById = async (req, res) => {
  try {
    const userId = req.user._id;
    const { paymentId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(paymentId)) {
      return res.status(400).json({ message: 'Invalid payment ID' });
    }

    const payment = await Payment.findOne({ _id: paymentId, userId }).lean();
    if (!payment) return res.status(404).json({ message: 'Payment not found' });

    res.json({ payment });
  } catch (e) {
    handleControllerError(res, e, 'Get payment by ID');
  }
};===== FILE: ./controllers/interestController.js =====
// ===== FILE: ./controllers/interestController.js =====

import mongoose from 'mongoose';
import Interest from '../models/Interest.js';
import Shortlist from '../models/Shortlist.js';
import Profile from '../models/Profile.js';
import User from '../models/User.js';
import { handleControllerError } from '../utils/errors.js';
import { parsePagination, formatPaginationResponse } from '../utils/pagination.js';
import { LIMITS } from '../utils/constants.js';

// Send interest
export const sendInterest = async (req, res) => {
  try {
    const { receiverId, message } = req.body;
    const senderId = req.user._id;

    if (!receiverId) return res.status(400).json({ message: 'Receiver ID required' });
    if (!mongoose.Types.ObjectId.isValid(receiverId)) return res.status(400).json({ message: 'Invalid receiver ID' });
    if (senderId.toString() === receiverId.toString()) return res.status(400).json({ message: 'Cannot send interest to yourself' });

    if (message && message.length > LIMITS.MAX_INTEREST_MESSAGE) {
      return res.status(400).json({ message: `Message too long (max ${LIMITS.MAX_INTEREST_MESSAGE} characters)` });
    }

    const receiverExists = await User.exists({ _id: receiverId });
    if (!receiverExists) return res.status(404).json({ message: 'User not found' });

    // ✅ FIX: Check if receiver has blocked the sender (reverse direction)
    const blockedBySender = await Interest.findOne({
      senderId: receiverId,
      receiverId: senderId,
      status: 'blocked',
    });
    if (blockedBySender) {
      return res.status(403).json({ message: 'Cannot send interest to this user' });
    }

    const existing = await Interest.findOne({ senderId, receiverId });
    if (existing) {
      return res.status(400).json({
        message: 'Interest already sent',
        status: existing.status,
        interestId: existing._id,
      });
    }

    const [senderProfile, receiverProfile] = await Promise.all([
      Profile.findOne({ userId: senderId }).select('_id'),
      Profile.findOne({ userId: receiverId }).select('_id'),
    ]);

    const interest = await Interest.create({
      senderId,
      receiverId,
      senderProfileId: senderProfile?._id,
      receiverProfileId: receiverProfile?._id,
      message: message?.trim(),
    });

    res.status(201).json({ message: 'Interest sent successfully', interest });
  } catch (e) {
    handleControllerError(res, e, 'Send interest');
  }
};

// Accept interest
export const acceptInterest = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user._id;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: 'Invalid interest ID' });
    }

    const interest = await Interest.findById(id);
    if (!interest) {
      return res.status(404).json({ message: 'Interest not found' });
    }

    if (interest.receiverId.toString() !== userId.toString()) {
      return res.status(403).json({ message: 'Not authorized to accept this interest' });
    }

    if (interest.status !== 'pending') {
      return res.status(400).json({
        message: `Interest already ${interest.status}`,
        status: interest.status,
      });
    }

    interest.status = 'accepted';
    interest.respondedAt = new Date();
    await interest.save();

    res.json({ message: 'Interest accepted', interest });
  } catch (e) {
    handleControllerError(res, e, 'Accept interest');
  }
};

// Decline interest
export const declineInterest = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason } = req.body;
    const userId = req.user._id;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: 'Invalid interest ID' });
    }

    const interest = await Interest.findById(id);
    if (!interest) {
      return res.status(404).json({ message: 'Interest not found' });
    }

    if (interest.receiverId.toString() !== userId.toString()) {
      return res.status(403).json({ message: 'Not authorized to decline this interest' });
    }

    if (interest.status !== 'pending') {
      return res.status(400).json({
        message: `Interest already ${interest.status}`,
        status: interest.status,
      });
    }

    interest.status = 'declined';
    interest.declineReason = reason?.trim();
    interest.respondedAt = new Date();
    await interest.save();

    res.json({ message: 'Interest declined', interest });
  } catch (e) {
    handleControllerError(res, e, 'Decline interest');
  }
};

// Block interest
export const blockInterest = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user._id;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: 'Invalid interest ID' });
    }

    const interest = await Interest.findById(id);
    if (!interest) {
      return res.status(404).json({ message: 'Interest not found' });
    }

    if (interest.receiverId.toString() !== userId.toString()) {
      return res.status(403).json({ message: 'Not authorized to block this interest' });
    }

    interest.status = 'blocked';
    interest.respondedAt = new Date();
    await interest.save();

    res.json({ message: 'User blocked', interest });
  } catch (e) {
    handleControllerError(res, e, 'Block interest');
  }
};

// Withdraw interest
export const withdrawInterest = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user._id;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: 'Invalid interest ID' });
    }

    const interest = await Interest.findById(id);
    if (!interest) {
      return res.status(404).json({ message: 'Interest not found' });
    }

    if (interest.senderId.toString() !== userId.toString()) {
      return res.status(403).json({ message: 'Not authorized to withdraw this interest' });
    }

    if (interest.status !== 'pending') {
      return res.status(400).json({
        message: `Cannot withdraw - interest already ${interest.status}`,
      });
    }

    interest.status = 'withdrawn';
    await interest.save();

    res.json({ message: 'Interest withdrawn' });
  } catch (e) {
    handleControllerError(res, e, 'Withdraw interest');
  }
};

// Get interests sent
export const getInterestsSent = async (req, res) => {
  try {
    const userId = req.user._id;
    const { status } = req.query;
    const { page, limit, skip } = parsePagination(req.query);

    const query = { senderId: userId };
    if (status && status !== 'all') {
      query.status = status;
    }

    const [interests, total] = await Promise.all([
      Interest.find(query)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .populate({
          path: 'receiverProfileId',
          select: 'fullName photos profileId age city occupation',
        })
        .lean(),
      Interest.countDocuments(query),
    ]);

    // Format response
    const formatted = interests.map((interest) => ({
      ...interest,
      receiverProfile: interest.receiverProfileId,
    }));

    res.json({
      interests: formatted,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get sent interests');
  }
};

// Get interests received
export const getInterestsReceived = async (req, res) => {
  try {
    const userId = req.user._id;
    const { status } = req.query;
    const { page, limit, skip } = parsePagination(req.query);

    const query = { receiverId: userId };
    if (status && status !== 'all') {
      query.status = status;
    }

    const [interests, total] = await Promise.all([
      Interest.find(query)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .populate({
          path: 'senderProfileId',
          select: 'fullName photos profileId age city occupation',
        })
        .lean(),
      Interest.countDocuments(query),
    ]);

    const formatted = interests.map((interest) => ({
      ...interest,
      senderProfile: interest.senderProfileId,
    }));

    res.json({
      interests: formatted,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get received interests');
  }
};

// Get accepted interests (matches)
export const getAcceptedInterests = async (req, res) => {
  try {
    const userId = req.user._id;
    const { page, limit, skip } = parsePagination(req.query);

    const query = {
      $or: [
        { senderId: userId, status: 'accepted' },
        { receiverId: userId, status: 'accepted' },
      ],
    };

    const [interests, total] = await Promise.all([
      Interest.find(query)
        .sort({ respondedAt: -1 })
        .skip(skip)
        .limit(limit)
        .populate('senderProfileId', 'fullName photos profileId age city')
        .populate('receiverProfileId', 'fullName photos profileId age city')
        .lean(),
      Interest.countDocuments(query),
    ]);

    res.json({
      interests,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get accepted interests');
  }
};

// Get declined interests
export const getDeclinedInterests = async (req, res) => {
  try {
    const userId = req.user._id;
    const { page, limit, skip } = parsePagination(req.query);

    const query = { receiverId: userId, status: 'declined' };

    const [interests, total] = await Promise.all([
      Interest.find(query)
        .sort({ respondedAt: -1 })
        .skip(skip)
        .limit(limit)
        .populate('senderProfileId', 'fullName photos profileId')
        .lean(),
      Interest.countDocuments(query),
    ]);

    res.json({
      interests,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get declined interests');
  }
};

// Get mutual interests
export const getMutualInterests = async (req, res) => {
  try {
    const userId = req.user._id;
    const { page, limit, skip } = parsePagination(req.query);

    // Find users where both have sent and accepted interests to each other
    const sentInterests = await Interest.find({
      senderId: userId,
      status: 'accepted',
    }).select('receiverId');

    const receiverIds = sentInterests.map((i) => i.receiverId);

    const mutualQuery = {
      senderId: { $in: receiverIds },
      receiverId: userId,
      status: 'accepted',
    };

    const [interests, total] = await Promise.all([
      Interest.find(mutualQuery)
        .sort({ respondedAt: -1 })
        .skip(skip)
        .limit(limit)
        .populate('senderProfileId', 'fullName photos profileId age city')
        .lean(),
      Interest.countDocuments(mutualQuery),
    ]);

    res.json({
      interests,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get mutual interests');
  }
};

// Get interest status between users
export const getInterestStatus = async (req, res) => {
  try {
    const { userId: targetUserId } = req.params;
    const currentUserId = req.user._id;

    if (!mongoose.Types.ObjectId.isValid(targetUserId)) {
      return res.status(400).json({ message: 'Invalid user ID' });
    }

    const [sent, received] = await Promise.all([
      Interest.findOne({ senderId: currentUserId, receiverId: targetUserId }),
      Interest.findOne({ senderId: targetUserId, receiverId: currentUserId }),
    ]);

    res.json({
      sent: sent ? { id: sent._id, status: sent.status } : null,
      received: received ? { id: received._id, status: received.status } : null,
      isMatch: sent?.status === 'accepted' && received?.status === 'accepted',
    });
  } catch (e) {
    handleControllerError(res, e, 'Get interest status');
  }
};

// === SHORTLIST ===

// Get shortlist
export const getShortlist = async (req, res) => {
  try {
    const userId = req.user._id;
    const { page, limit, skip } = parsePagination(req.query);

    const [shortlist, total] = await Promise.all([
      Shortlist.find({ userId })
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .populate({
          path: 'shortlistedProfileId',
          select: 'fullName photos profileId age city occupation',
        })
        .lean(),
      Shortlist.countDocuments({ userId }),
    ]);

    res.json({
      shortlist,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get shortlist');
  }
};

// Add to shortlist
export const addToShortlist = async (req, res) => {
  try {
    const userId = req.user._id;
    const { userId: targetUserId } = req.params;
    const { note } = req.body;

    if (!mongoose.Types.ObjectId.isValid(targetUserId)) {
      return res.status(400).json({ message: 'Invalid user ID' });
    }

    if (userId.toString() === targetUserId) {
      return res.status(400).json({ message: 'Cannot shortlist yourself' });
    }

    // Check if target user exists
    const targetExists = await User.exists({ _id: targetUserId });
    if (!targetExists) {
      return res.status(404).json({ message: 'User not found' });
    }

    const existing = await Shortlist.findOne({
      userId,
      shortlistedUserId: targetUserId,
    });

    if (existing) {
      return res.status(400).json({ message: 'Already shortlisted' });
    }

    const profile = await Profile.findOne({ userId: targetUserId }).select('_id');

    const shortlist = await Shortlist.create({
      userId,
      shortlistedUserId: targetUserId,
      shortlistedProfileId: profile?._id,
      note: note?.trim(),
    });

    res.status(201).json({ message: 'Added to shortlist', shortlist });
  } catch (e) {
    handleControllerError(res, e, 'Add to shortlist');
  }
};

// Remove from shortlist
export const removeFromShortlist = async (req, res) => {
  try {
    const userId = req.user._id;
    const { userId: targetUserId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(targetUserId)) {
      return res.status(400).json({ message: 'Invalid user ID' });
    }

    const result = await Shortlist.findOneAndDelete({
      userId,
      shortlistedUserId: targetUserId,
    });

    if (!result) {
      return res.status(404).json({ message: 'Not in shortlist' });
    }

    res.json({ message: 'Removed from shortlist' });
  } catch (e) {
    handleControllerError(res, e, 'Remove from shortlist');
  }
};

// Check if shortlisted
export const isShortlisted = async (req, res) => {
  try {
    const userId = req.user._id;
    const { userId: targetUserId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(targetUserId)) {
      return res.status(400).json({ message: 'Invalid user ID' });
    }

    const exists = await Shortlist.exists({
      userId,
      shortlistedUserId: targetUserId,
    });

    res.json({ isShortlisted: !!exists });
  } catch (e) {
    handleControllerError(res, e, 'Check shortlist');
  }
};

// Update shortlist note
export const updateShortlistNote = async (req, res) => {
  try {
    const userId = req.user._id;
    const { userId: targetUserId } = req.params;
    const { note } = req.body;

    if (!mongoose.Types.ObjectId.isValid(targetUserId)) {
      return res.status(400).json({ message: 'Invalid user ID' });
    }

    const shortlist = await Shortlist.findOneAndUpdate(
      { userId, shortlistedUserId: targetUserId },
      { note: note?.trim() },
      { new: true }
    );

    if (!shortlist) {
      return res.status(404).json({ message: 'Not in shortlist' });
    }

    res.json({ message: 'Note updated', shortlist });
  } catch (e) {
    handleControllerError(res, e, 'Update shortlist note');
  }
};===== FILE: ./controllers/notificationController.js =====
// ===== FILE: ./controllers/notificationController.js =====
import mongoose from 'mongoose';
import Notification from '../models/Notification.js';
import { handleControllerError } from '../utils/errors.js';
import { parsePagination, formatPaginationResponse } from '../utils/pagination.js';

export const getNotifications = async (req, res) => {
  try {
    const userId = req.user._id;
    const { page, limit, skip } = parsePagination(req.query);
    const { type, read } = req.query;

    const filter = { userId };
    if (type) filter.type = type;
    if (read !== undefined) filter.read = String(read) === 'true';

    const [notifications, total] = await Promise.all([
      Notification.find(filter)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .lean(),
      Notification.countDocuments(filter),
    ]);

    res.json({
      notifications,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get notifications');
  }
};

export const getUnreadCount = async (req, res) => {
  try {
    const userId = req.user._id;
    const count = await Notification.countDocuments({ userId, read: false });
    res.json({ unreadCount: count });
  } catch (e) {
    handleControllerError(res, e, 'Get unread count');
  }
};

export const markAsRead = async (req, res) => {
  try {
    const userId = req.user._id;
    const { id } = req.params;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: 'Invalid notification ID' });
    }

    const notification = await Notification.findOneAndUpdate(
      { _id: id, userId },
      { read: true, readAt: new Date() },
      { new: true }
    ).lean();

    if (!notification) return res.status(404).json({ message: 'Notification not found' });

    res.json({ message: 'Notification marked as read', notification });
  } catch (e) {
    handleControllerError(res, e, 'Mark as read');
  }
};

export const markAllAsRead = async (req, res) => {
  try {
    const userId = req.user._id;

    await Notification.updateMany(
      { userId, read: false },
      { read: true, readAt: new Date() }
    );

    res.json({ message: 'All notifications marked as read' });
  } catch (e) {
    handleControllerError(res, e, 'Mark all as read');
  }
};

export const deleteNotification = async (req, res) => {
  try {
    const userId = req.user._id;
    const { id } = req.params;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: 'Invalid notification ID' });
    }

    const deleted = await Notification.findOneAndDelete({ _id: id, userId }).lean();
    if (!deleted) return res.status(404).json({ message: 'Notification not found' });

    res.json({ message: 'Notification deleted' });
  } catch (e) {
    handleControllerError(res, e, 'Delete notification');
  }
};

export const deleteAllNotifications = async (req, res) => {
  try {
    const userId = req.user._id;
    await Notification.deleteMany({ userId });
    res.json({ message: 'All notifications deleted' });
  } catch (e) {
    handleControllerError(res, e, 'Delete all notifications');
  }
};

export default {
  getNotifications,
  getUnreadCount,
  markAsRead,
  markAllAsRead,
  deleteNotification,
  deleteAllNotifications,
};===== FILE: ./controllers/profileController.js =====
// ===== UPDATED FILE: ./controllers/profileController.js =====
import mongoose from 'mongoose';
import Profile from '../models/Profile.js';
import User from '../models/User.js';
import Interest from '../models/Interest.js';
import { applyProfilePrivacy } from '../utils/privacy.js';
import { LIMITS } from '../utils/constants.js';

// ==================== HELPER FUNCTIONS ====================

// Generate unique profile ID (using native JS - no uuid needed)
const generateProfileId = () => {
  const prefix = 'MAT';
  const timestamp = Date.now().toString(36).toUpperCase();
  const random = Math.random().toString(36).substring(2, 6).toUpperCase();
  return `${prefix}${timestamp}${random}`;
};

// Calculate age from date of birth
const calculateAge = (dateOfBirth) => {
  if (!dateOfBirth) return null;
  const today = new Date();
  const birthDate = new Date(dateOfBirth);
  let age = today.getFullYear() - birthDate.getFullYear();
  const monthDiff = today.getMonth() - birthDate.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
    age--;
  }
  return age;
};

// Calculate profile completion percentage
const calculateCompletion = (profile) => {
  const details = {};

  // Basic Info (25% weight)
  const basicFields = ['fullName', 'gender', 'dateOfBirth', 'maritalStatus', 'religion'];
  const basicOptional = ['caste', 'motherTongue', 'bio'];
  const basicFilled = basicFields.filter((f) => profile[f]).length;
  const basicOptionalFilled = basicOptional.filter((f) => profile[f]).length;
  details.basicInfo = Math.round(
    ((basicFilled / basicFields.length) * 80) +
    ((basicOptionalFilled / Math.max(basicOptional.length, 1)) * 20)
  );

  // Physical Attributes (15% weight)
  const hasHeight = profile.height && (
    (typeof profile.height === 'object' && profile.height.cm) ||
    (typeof profile.height === 'number' && profile.height > 0)
  );
  const physicalOptional = ['weight', 'bodyType', 'complexion', 'physicalStatus'];
  const physicalOptionalFilled = physicalOptional.filter((f) => profile[f]).length;
  details.physicalAttributes = Math.round(
    (hasHeight ? 50 : 0) +
    ((physicalOptionalFilled / Math.max(physicalOptional.length, 1)) * 50)
  );

  // Lifestyle (10% weight)
  const lifestyleFields = ['diet', 'smoking', 'drinking'];
  const lifestyleFilled = lifestyleFields.filter((f) => profile[f]).length;
  const hobbiesFilled = profile.hobbies?.length > 0 ? 1 : 0;
  details.lifestyle = Math.round(
    ((lifestyleFilled / Math.max(lifestyleFields.length, 1)) * 70) +
    (hobbiesFilled * 30)
  );

  // Location & Career (20% weight)
  const locationFields = ['country', 'city'];
  const locationOptional = ['state', 'citizenship', 'residencyStatus'];
  const careerFields = ['education', 'occupation'];
  const careerOptional = ['educationField', 'institution', 'company', 'jobTitle', 'annualIncome'];

  const locationFilled = locationFields.filter((f) => profile[f]).length;
  const locationOptionalFilled = locationOptional.filter((f) => profile[f]).length;
  const careerFilled = careerFields.filter((f) => profile[f]).length;
  const careerOptionalFilled = careerOptional.filter((f) => profile[f]).length;

  details.location = Math.round(
    ((locationFilled / locationFields.length) * 40) +
    ((locationOptionalFilled / Math.max(locationOptional.length, 1)) * 10) +
    ((careerFilled / Math.max(careerFields.length, 1)) * 30) +
    ((careerOptionalFilled / Math.max(careerOptional.length, 1)) * 20)
  );

  // Education
  details.education = careerFilled > 0
    ? Math.round((careerFilled / Math.max(careerFields.length, 1)) * 100)
    : 0;

  // Photos (15% weight)
  const photoCount = profile.photos?.length || 0;
  details.photos = Math.min(100, photoCount * 25);

  // Partner Preferences (15% weight)
  const prefs = profile.partnerPreferences || {};
  const prefFields = ['ageRange', 'heightRange', 'religion', 'education', 'maritalStatus'];
  const prefsFilled = prefFields.filter((f) => {
    const val = prefs[f];
    if (!val) return false;
    if (Array.isArray(val)) return val.length > 0;
    if (typeof val === 'object') return Object.keys(val).length > 0;
    return true;
  }).length;
  details.partnerPreferences = Math.round((prefsFilled / Math.max(prefFields.length, 1)) * 100);

  // Calculate overall percentage
  const weights = {
    basicInfo: 0.25,
    physicalAttributes: 0.15,
    lifestyle: 0.10,
    location: 0.20,
    photos: 0.15,
    partnerPreferences: 0.15,
  };

  const percentage = Math.round(
    (details.basicInfo * weights.basicInfo) +
    (details.physicalAttributes * weights.physicalAttributes) +
    (details.lifestyle * weights.lifestyle) +
    (details.location * weights.location) +
    (details.photos * weights.photos) +
    (details.partnerPreferences * weights.partnerPreferences)
  );

  return { percentage, details };
};

// Helper: resolve viewer user doc (for entitlements/privacy)
const getViewerUserDoc = async (req) => {
  const viewerId = req.user?.id || req.user?._id;
  if (!viewerId) return null;
  try {
    return await User.findById(viewerId).lean();
  } catch {
    return null;
  }
};

// Helper: is viewer connected (accepted interest) with profile owner?
const isMatchWith = async (viewerId, otherUserId) => {
  if (!viewerId || !otherUserId) return false;

  const exists = await Interest.exists({
    status: 'accepted',
    $or: [
      { senderId: viewerId, receiverId: otherUserId },
      { senderId: otherUserId, receiverId: viewerId },
    ],
  });

  return !!exists;
};

// ==================== PROFILE CRUD ====================

export const getMyProfile = async (req, res) => {
  try {
    const { id: userId } = req.user;

    const profile = await Profile.findOne({ userId })
      .populate('userId', 'email phone countryCode isEmailVerified isPhoneVerified isPremium');

    if (!profile) {
      return res.status(404).json({ message: 'Profile not found', profile: null });
    }

    res.json({ profile });
  } catch (error) {
    console.error('Get profile error:', error);
    res.status(500).json({ message: 'Server error fetching profile' });
  }
};

export const createProfile = async (req, res) => {
  try {
    const { id: userId } = req.user;

    const existingProfile = await Profile.findOne({ userId });
    if (existingProfile) {
      return res.status(400).json({ message: 'Profile already exists. Use PUT to update.' });
    }

    const {
      fullName,
      gender,
      dateOfBirth,
      maritalStatus,
      religion,
      country,
      city,
      caste,
      subCaste,
      motherTongue,
      bio,
      height,
      weight,
      bodyType,
      complexion,
      physicalStatus,
      diet,
      smoking,
      drinking,
      hobbies,
      interests,
      languages,
      state,
      citizenship,
      residencyStatus,
      education,
      educationField,
      institution,
      occupation,
      employmentType,
      company,
      jobTitle,
      annualIncome,
      partnerPreferences,
      privacySettings,
    } = req.body;

    const errors = [];
    if (!fullName?.trim()) errors.push({ field: 'fullName', message: 'Full name is required' });
    if (!gender) errors.push({ field: 'gender', message: 'Gender is required' });
    if (!dateOfBirth) errors.push({ field: 'dateOfBirth', message: 'Date of birth is required' });
    if (!maritalStatus) errors.push({ field: 'maritalStatus', message: 'Marital status is required' });
    if (!religion?.trim()) errors.push({ field: 'religion', message: 'Religion is required' });
    if (!country?.trim()) errors.push({ field: 'country', message: 'Country is required' });
    if (!city?.trim()) errors.push({ field: 'city', message: 'City is required' });

    if (errors.length > 0) return res.status(400).json({ message: 'Validation failed', errors });

    if (!['male', 'female'].includes(gender)) {
      return res.status(400).json({
        message: 'Validation failed',
        errors: [{ field: 'gender', message: 'Gender must be male or female' }],
      });
    }

    const validMaritalStatus = ['never_married', 'divorced', 'widowed', 'awaiting_divorce', 'annulled'];
    if (!validMaritalStatus.includes(maritalStatus)) {
      return res.status(400).json({
        message: 'Validation failed',
        errors: [{ field: 'maritalStatus', message: 'Invalid marital status' }],
      });
    }

    const age = calculateAge(dateOfBirth);
    if (age < 18) {
      return res.status(400).json({
        message: 'Validation failed',
        errors: [{ field: 'dateOfBirth', message: 'You must be at least 18 years old' }],
      });
    }

    const profileId = generateProfileId();

    const profileData = {
      userId,
      profileId,
      fullName: fullName.trim(),
      gender,
      dateOfBirth: new Date(dateOfBirth),
      age,
      maritalStatus,
      religion: religion.trim(),
      country: country.trim(),
      city: city.trim(),
    };

    const optionalStringFields = {
      caste,
      subCaste,
      motherTongue,
      bio,
      state,
      citizenship,
      educationField,
      institution,
      occupation,
      company,
      jobTitle,
    };

    Object.entries(optionalStringFields).forEach(([key, value]) => {
      if (value?.trim()) profileData[key] = value.trim();
    });

    const optionalEnumFields = {
      residencyStatus,
      education,
      employmentType,
      annualIncome,
      bodyType,
      complexion,
      physicalStatus,
      diet,
      smoking,
      drinking,
    };

    Object.entries(optionalEnumFields).forEach(([key, value]) => {
      if (value) profileData[key] = value;
    });

    if (height) profileData.height = height;

    if (weight) profileData.weight = typeof weight === 'number' ? weight : parseInt(weight, 10);

    if (Array.isArray(hobbies) && hobbies.length > 0) profileData.hobbies = hobbies;
    if (Array.isArray(interests) && interests.length > 0) profileData.interests = interests;
    if (Array.isArray(languages) && languages.length > 0) profileData.languages = languages;

    if (partnerPreferences && typeof partnerPreferences === 'object') {
      profileData.partnerPreferences = partnerPreferences;
    }

    if (privacySettings && typeof privacySettings === 'object') {
      profileData.privacySettings = {
        showPhone: Boolean(privacySettings.showPhone),
        showEmail: Boolean(privacySettings.showEmail),
        showIncome: Boolean(privacySettings.showIncome),
        photoVisibility: privacySettings.photoVisibility || 'all',
        profileVisibility: privacySettings.profileVisibility || 'all',
      };
    }

    const { percentage, details } = calculateCompletion(profileData);
    profileData.completionPercentage = percentage;
    profileData.completionDetails = details;

    const profile = await Profile.create(profileData);

    await User.findByIdAndUpdate(userId, { profileId: profile._id, fullName: profile.fullName });

    res.status(201).json({ message: 'Profile created successfully', profile });
  } catch (error) {
    console.error('Create profile error:', error);

    if (error.name === 'ValidationError') {
      const errors = Object.values(error.errors).map((err) => ({ field: err.path, message: err.message }));
      return res.status(400).json({ message: 'Validation failed', errors });
    }

    if (error.code === 11000) return res.status(400).json({ message: 'Profile already exists' });

    res.status(500).json({ message: 'Server error creating profile' });
  }
};

export const updateProfile = async (req, res) => {
  try {
    const { id: userId } = req.user;

    const profile = await Profile.findOne({ userId });
    if (!profile) return res.status(404).json({ message: 'Profile not found. Create one first.' });

    const allowedUpdates = [
      'fullName', 'gender', 'dateOfBirth', 'maritalStatus', 'religion',
      'caste', 'subCaste', 'motherTongue', 'bio',
      'height', 'weight', 'bodyType', 'complexion', 'physicalStatus',
      'diet', 'smoking', 'drinking', 'hobbies', 'interests', 'languages',
      'country', 'state', 'city', 'citizenship', 'residencyStatus',
      'education', 'educationField', 'institution', 'occupation',
      'employmentType', 'company', 'jobTitle', 'annualIncome',
      'partnerPreferences', 'privacySettings',
    ];

    const updates = {};
    const errors = [];

    for (const field of allowedUpdates) {
      if (req.body[field] === undefined) continue;

      const value = req.body[field];

      switch (field) {
        case 'fullName':
          if (!value?.trim()) errors.push({ field, message: 'Full name cannot be empty' });
          else updates[field] = value.trim();
          break;

        case 'gender':
          if (!['male', 'female'].includes(value)) errors.push({ field, message: 'Gender must be male or female' });
          else updates[field] = value;
          break;

        case 'maritalStatus': {
          const validStatus = ['never_married', 'divorced', 'widowed', 'awaiting_divorce', 'annulled'];
          if (!validStatus.includes(value)) errors.push({ field, message: 'Invalid marital status' });
          else updates[field] = value;
          break;
        }

        case 'dateOfBirth': {
          const age = calculateAge(value);
          if (age < 18) errors.push({ field, message: 'You must be at least 18 years old' });
          else {
            updates[field] = new Date(value);
            updates.age = age;
          }
          break;
        }

        case 'height':
          updates[field] = value;
          break;

        case 'weight':
          updates[field] = typeof value === 'number' ? value : parseInt(value, 10) || null;
          break;

        case 'privacySettings':
          if (typeof value === 'object') {
            updates[field] = {
              showPhone: Boolean(value.showPhone),
              showEmail: Boolean(value.showEmail),
              showIncome: Boolean(value.showIncome),
              photoVisibility: value.photoVisibility || profile.privacySettings?.photoVisibility || 'all',
              profileVisibility: value.profileVisibility || profile.privacySettings?.profileVisibility || 'all',
            };
          }
          break;

        case 'partnerPreferences':
          if (typeof value === 'object') {
            const existingPrefs = profile.partnerPreferences?.toObject?.() || profile.partnerPreferences || {};
            updates[field] = { ...existingPrefs, ...value };
          }
          break;

        case 'hobbies':
        case 'interests':
        case 'languages':
          if (Array.isArray(value)) updates[field] = value;
          break;

        default:
          if (typeof value === 'string') updates[field] = value.trim() || undefined;
          else updates[field] = value;
      }
    }

    if (errors.length > 0) return res.status(400).json({ message: 'Validation failed', errors });

    Object.assign(profile, updates);

    const { percentage, details } = calculateCompletion(profile);
    profile.completionPercentage = percentage;
    profile.completionDetails = details;
    await profile.save();

    if (updates.fullName) await User.findByIdAndUpdate(userId, { fullName: updates.fullName });

    res.json({ message: 'Profile updated successfully', profile, completion: { percentage, details } });
  } catch (error) {
    console.error('Update profile error:', error);

    if (error.name === 'ValidationError') {
      const errors = Object.values(error.errors).map((err) => ({ field: err.path, message: err.message }));
      return res.status(400).json({ message: 'Validation failed', errors });
    }

    res.status(500).json({ message: 'Server error updating profile' });
  }
};

export const deleteProfile = async (req, res) => {
  try {
    const { id: userId } = req.user;

    const profile = await Profile.findOneAndDelete({ userId });
    if (!profile) return res.status(404).json({ message: 'Profile not found' });

    await User.findByIdAndUpdate(userId, { $unset: { profileId: 1, fullName: 1 } });

    res.json({ message: 'Profile deleted successfully' });
  } catch (error) {
    console.error('Delete profile error:', error);
    res.status(500).json({ message: 'Server error deleting profile' });
  }
};

// ==================== PROFILE COMPLETION ====================

export const getCompletion = async (req, res) => {
  try {
    const { id: userId } = req.user;
    const profile = await Profile.findOne({ userId });

    if (!profile) {
      return res.json({
        percentage: 0,
        details: {
          basicInfo: 0,
          physicalAttributes: 0,
          lifestyle: 0,
          location: 0,
          education: 0,
          photos: 0,
          partnerPreferences: 0,
        },
      });
    }

    const { percentage, details } = calculateCompletion(profile);

    if (profile.completionPercentage !== percentage || !profile.completionDetails) {
      profile.completionPercentage = percentage;
      profile.completionDetails = details;
      await profile.save();
    }

    res.json({ percentage, details });
  } catch (error) {
    console.error('Get completion error:', error);
    res.status(500).json({ message: 'Failed to calculate profile completion' });
  }
};

// ==================== PROFILE BY ID (PUBLIC) ====================

export const getProfileById = async (req, res) => {
  try {
    const { profileId } = req.params;

    const or = [{ profileId }];
    if (mongoose.Types.ObjectId.isValid(profileId)) {
      or.push({ _id: profileId });
    }

    const profile = await Profile.findOne({ $or: or })
      .populate('userId', 'email phone countryCode isPremium isEmailVerified isPhoneVerified lastActive')
      .lean();

    if (!profile) return res.status(404).json({ message: 'Profile not found' });

    const viewer = await getViewerUserDoc(req);

    const profileOwnerId = profile.userId?._id || profile.userId;
    const match = viewer?._id ? await isMatchWith(viewer._id, profileOwnerId) : false;

    const safeProfile = applyProfilePrivacy({
      viewer,
      profile,
      isMatch: match,
    });

    if (viewer?._id && profileOwnerId && viewer._id.toString() !== profileOwnerId.toString()) {
      await Profile.updateOne({ _id: profile._id }, { $inc: { profileViews: 1 } });
    }

    res.json({ profile: safeProfile });
  } catch (error) {
    console.error('Get profile by ID error:', error);
    res.status(500).json({ message: 'Server error fetching profile' });
  }
};

// ==================== PHOTOS ====================

export const uploadPhotos = async (req, res) => {
  try {
    const { id: userId } = req.user;

    const profile = await Profile.findOne({ userId });
    if (!profile) {
      return res.status(404).json({ message: 'Profile not found. Create profile first.' });
    }

    if (!req.files || req.files.length === 0) {
      return res.status(400).json({ message: 'No files uploaded' });
    }

    const newPhotos = req.files.map((file, index) => ({
      url: file.location || `/uploads/${file.filename}`,
      publicId: file.filename || file.key,
      isProfile: profile.photos.length === 0 && index === 0,
      uploadedAt: new Date(),
    }));

    const maxPhotos = LIMITS.MAX_PHOTOS;
    const currentCount = profile.photos.length;
    const allowedCount = Math.min(newPhotos.length, maxPhotos - currentCount);

    if (allowedCount <= 0) {
      return res.status(400).json({ message: `Maximum ${maxPhotos} photos allowed` });
    }

    profile.photos.push(...newPhotos.slice(0, allowedCount));

    const { percentage, details } = calculateCompletion(profile);
    profile.completionPercentage = percentage;
    profile.completionDetails = details;

    await profile.save();

    res.json({ message: `${allowedCount} photo(s) uploaded successfully`, photos: profile.photos });
  } catch (error) {
    console.error('Upload photos error:', error);
    res.status(500).json({ message: 'Server error uploading photos' });
  }
};

export const deletePhoto = async (req, res) => {
  try {
    const { id: userId } = req.user;
    const { photoId } = req.params;

    const profile = await Profile.findOne({ userId });
    if (!profile) return res.status(404).json({ message: 'Profile not found' });

    const photoIndex = profile.photos.findIndex(
      (p) => p._id.toString() === photoId || p.publicId === photoId
    );
    if (photoIndex === -1) return res.status(404).json({ message: 'Photo not found' });

    const wasProfilePhoto = profile.photos[photoIndex].isProfile;

    profile.photos.splice(photoIndex, 1);

    if (wasProfilePhoto && profile.photos.length > 0) {
      profile.photos[0].isProfile = true;
    }

    const { percentage, details } = calculateCompletion(profile);
    profile.completionPercentage = percentage;
    profile.completionDetails = details;

    await profile.save();

    res.json({ message: 'Photo deleted successfully', photos: profile.photos });
  } catch (error) {
    console.error('Delete photo error:', error);
    res.status(500).json({ message: 'Server error deleting photo' });
  }
};

export const setProfilePhoto = async (req, res) => {
  try {
    const { id: userId } = req.user;
    const { photoId } = req.params;

    const profile = await Profile.findOne({ userId });
    if (!profile) return res.status(404).json({ message: 'Profile not found' });

    const photoIndex = profile.photos.findIndex(
      (p) => p._id.toString() === photoId || p.publicId === photoId
    );
    if (photoIndex === -1) return res.status(404).json({ message: 'Photo not found' });

    profile.photos.forEach((p) => { p.isProfile = false; });
    profile.photos[photoIndex].isProfile = true;

    await profile.save();

    res.json({ message: 'Profile photo updated', photos: profile.photos });
  } catch (error) {
    console.error('Set profile photo error:', error);
    res.status(500).json({ message: 'Server error setting profile photo' });
  }
};

// ==================== PREFERENCES & SETTINGS ====================

export const updatePartnerPreferences = async (req, res) => {
  try {
    const { id: userId } = req.user;

    const profile = await Profile.findOne({ userId });
    if (!profile) return res.status(404).json({ message: 'Profile not found' });

    const allowedFields = [
      'ageRange', 'heightRange', 'religion', 'caste', 'motherTongue',
      'education', 'occupation', 'annualIncome', 'maritalStatus',
      'diet', 'smoking', 'drinking', 'country', 'state', 'city',
      'aboutPartner',
    ];

    const updates = {};
    for (const field of allowedFields) {
      if (req.body[field] !== undefined) updates[field] = req.body[field];
    }

    const existingPrefs = profile.partnerPreferences?.toObject?.() || profile.partnerPreferences || {};
    profile.partnerPreferences = { ...existingPrefs, ...updates };

    const { percentage, details } = calculateCompletion(profile);
    profile.completionPercentage = percentage;
    profile.completionDetails = details;

    await profile.save();

    res.json({
      message: 'Partner preferences updated',
      partnerPreferences: profile.partnerPreferences,
      completion: { percentage, details },
    });
  } catch (error) {
    console.error('Update partner preferences error:', error);
    res.status(500).json({ message: 'Server error updating preferences' });
  }
};

export const updatePrivacySettings = async (req, res) => {
  try {
    const { id: userId } = req.user;

    const profile = await Profile.findOne({ userId });
    if (!profile) return res.status(404).json({ message: 'Profile not found' });

    const { showPhone, showEmail, showIncome, photoVisibility, profileVisibility } = req.body;

    profile.privacySettings = {
      showPhone: showPhone !== undefined ? Boolean(showPhone) : profile.privacySettings?.showPhone,
      showEmail: showEmail !== undefined ? Boolean(showEmail) : profile.privacySettings?.showEmail,
      showIncome: showIncome !== undefined ? Boolean(showIncome) : profile.privacySettings?.showIncome,
      photoVisibility: photoVisibility || profile.privacySettings?.photoVisibility || 'all',
      profileVisibility: profileVisibility || profile.privacySettings?.profileVisibility || 'all',
    };

    await profile.save();

    res.json({ message: 'Privacy settings updated', privacySettings: profile.privacySettings });
  } catch (error) {
    console.error('Update privacy settings error:', error);
    res.status(500).json({ message: 'Server error updating privacy settings' });
  }
};

// ==================== DEFAULT EXPORT ====================

export default {
  getMyProfile,
  createProfile,
  updateProfile,
  deleteProfile,
  getCompletion,
  getProfileById,
  uploadPhotos,
  deletePhoto,
  setProfilePhoto,
  updatePartnerPreferences,
  updatePrivacySettings,
};===== FILE: ./controllers/adminPlanController.js =====
import mongoose from 'mongoose';
import Plan from '../models/Plan.js';
import AdminLog from '../models/AdminLog.js';

const log = async (req, action, planId, metadata = {}) => {
  try {
    await AdminLog.create({
      adminId: req.user._id,
      action,
      targetUserId: null,
      reason: null,
      metadata: { planId, ...metadata },
      ipAddress: req?.ip,
      userAgent: req?.get?.('user-agent'),
    });
  } catch (_) {}
};

const normalizePrice = (obj) => {
  if (!obj || typeof obj !== 'object') return null;
  const out = {};
  for (const [k, v] of Object.entries(obj)) {
    if (v === '' || v === null || v === undefined) continue;
    const n = Number(v);
    if (Number.isFinite(n) && n >= 0) out[String(k).toUpperCase()] = n;
  }
  return Object.keys(out).length ? out : null;
};

export const listPlans = async (_req, res) => {
  try {
    const plans = await Plan.find({}).sort({ sortOrder: 1, createdAt: -1 });
    res.json({ plans });
  } catch (e) {
    res.status(500).json({ message: 'Error fetching plans', error: e.message });
  }
};

export const createPlan = async (req, res) => {
  try {
    const { name, slug, duration, price } = req.body || {};
    if (!name || !slug) return res.status(400).json({ message: 'name and slug are required' });
    if (!duration?.value || !duration?.unit) {
      return res.status(400).json({ message: 'duration.value and duration.unit are required' });
    }

    const normalizedPrice = normalizePrice(price);
    if (!normalizedPrice) return res.status(400).json({ message: 'Valid price required, ex: { INR: 999 }' });

    const exists = await Plan.findOne({ slug });
    if (exists) return res.status(400).json({ message: 'slug already exists' });

    const plan = await Plan.create({
      name,
      slug,
      description: req.body.description || '',
      price: normalizedPrice,
      discountPrice: normalizePrice(req.body.discountPrice) || undefined,
      duration: { value: Number(duration.value), unit: duration.unit },
      features: req.body.features && typeof req.body.features === 'object' ? req.body.features : {},
      recommended: !!req.body.recommended,
      isActive: req.body.isActive !== false,
      sortOrder: Number(req.body.sortOrder) || 0,
    });

    await log(req, 'plan_created', plan._id.toString(), { slug: plan.slug });
    res.status(201).json({ plan });
  } catch (e) {
    if (e.code === 11000) return res.status(400).json({ message: 'Duplicate key (slug probably exists)' });
    res.status(500).json({ message: 'Error creating plan', error: e.message });
  }
};

export const updatePlan = async (req, res) => {
  try {
    const { planId } = req.params;
    if (!mongoose.Types.ObjectId.isValid(planId)) return res.status(400).json({ message: 'Invalid planId' });

    const updates = { ...req.body };

    if (updates.price !== undefined) {
      const normalizedPrice = normalizePrice(updates.price);
      if (!normalizedPrice) return res.status(400).json({ message: 'Invalid price object' });
      updates.price = normalizedPrice;
    }

    if (updates.discountPrice !== undefined) {
      updates.discountPrice = normalizePrice(updates.discountPrice) || undefined;
    }

    if (updates.duration !== undefined) {
      if (!updates.duration?.value || !updates.duration?.unit) {
        return res.status(400).json({ message: 'duration.value and duration.unit are required' });
      }
      updates.duration = { value: Number(updates.duration.value), unit: updates.duration.unit };
    }

    if (updates.slug) {
      const exists = await Plan.findOne({ slug: updates.slug, _id: { $ne: planId } });
      if (exists) return res.status(400).json({ message: 'slug already exists' });
    }

    const plan = await Plan.findByIdAndUpdate(planId, updates, { new: true, runValidators: true });
    if (!plan) return res.status(404).json({ message: 'Plan not found' });

    await log(req, 'plan_updated', planId, { fields: Object.keys(updates) });
    res.json({ plan });
  } catch (e) {
    res.status(500).json({ message: 'Error updating plan', error: e.message });
  }
};

export const togglePlan = async (req, res) => {
  try {
    const { planId } = req.params;
    const plan = await Plan.findById(planId);
    if (!plan) return res.status(404).json({ message: 'Plan not found' });

    plan.isActive = !plan.isActive;
    await plan.save();

    await log(req, plan.isActive ? 'plan_activated' : 'plan_deactivated', planId);
    res.json({ plan });
  } catch (e) {
    res.status(500).json({ message: 'Error toggling plan', error: e.message });
  }
};

export const deletePlan = async (req, res) => {
  try {
    const { planId } = req.params;
    const plan = await Plan.findById(planId);
    if (!plan) return res.status(404).json({ message: 'Plan not found' });

    // soft delete
    plan.isActive = false;
    await plan.save();

    await log(req, 'plan_deleted_soft', planId);
    res.json({ message: 'Plan deactivated', plan });
  } catch (e) {
    res.status(500).json({ message: 'Error deleting plan', error: e.message });
  }
};

export const reorderPlans = async (req, res) => {
  try {
    const { order } = req.body || {};
    if (!Array.isArray(order) || order.length === 0) {
      return res.status(400).json({ message: 'order must be an array of planIds' });
    }

    const ops = order
      .filter((id) => mongoose.Types.ObjectId.isValid(id))
      .map((id, idx) => ({
        updateOne: { filter: { _id: id }, update: { $set: { sortOrder: idx } } },
      }));

    if (ops.length === 0) return res.status(400).json({ message: 'No valid planIds provided' });

    await Plan.bulkWrite(ops);

    await log(req, 'plans_reordered', null, { count: ops.length });

    const plans = await Plan.find({}).sort({ sortOrder: 1, createdAt: -1 });
    res.json({ plans });
  } catch (e) {
    res.status(500).json({ message: 'Error reordering plans', error: e.message });
  }
};===== FILE: ./controllers/adminController.js =====
// ===== FIXED FILE: ./controllers/adminController.js =====
import mongoose from 'mongoose';
import User from '../models/User.js';
import Profile from '../models/Profile.js';
import Report from '../models/Report.js';
import AdminLog from '../models/AdminLog.js';
import Interest from '../models/Interest.js'; // ✅ FIX: Added for cleanup
import Shortlist from '../models/Shortlist.js'; // ✅ FIX: Added for cleanup
import Notification from '../models/Notification.js'; // ✅ FIX: Added for cleanup
import Message from '../models/Message.js'; // ✅ FIX: Added for cleanup
import Conversation from '../models/Conversation.js'; // ✅ FIX: Added for cleanup
import Subscription from '../models/Subscription.js'; // ✅ FIX: Added for cleanup
import Payment from '../models/Payment.js'; // ✅ FIX: Added for cleanup
import { handleControllerError } from '../utils/errors.js';
import { parsePagination, formatPaginationResponse } from '../utils/pagination.js';

const escapeRegex = (s = '') => String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

const logAdminAction = async (req, adminId, action, targetUserId, reason, metadata = {}) => {
  try {
    await AdminLog.create({
      adminId,
      action,
      targetUserId,
      reason: reason || null,
      metadata,
      ipAddress: req?.ip,
      userAgent: req?.get?.('user-agent'),
    });
  } catch (e) {
    console.error('Error logging admin action:', e.message);
  }
};

// ✅ FIX: Extracted shared cleanup helper for user deletion
const cleanupUserData = async (userId, session) => {
  await Profile.deleteOne({ userId }).session(session);
  await Interest.deleteMany({
    $or: [{ senderId: userId }, { receiverId: userId }],
  }).session(session);
  await Shortlist.deleteMany({
    $or: [{ userId }, { shortlistedUserId: userId }],
  }).session(session);
  await Notification.deleteMany({ userId }).session(session);
  await Message.updateMany(
    { $or: [{ senderId: userId }, { receiverId: userId }] },
    { isDeleted: true, deletedAt: new Date() }
  ).session(session);
  await Subscription.deleteOne({ userId }).session(session);
  await Payment.deleteMany({ userId }).session(session);

  const userConversations = await Conversation.find({ participants: userId })
    .select('_id')
    .session(session);
  for (const conv of userConversations) {
    await Message.updateMany(
      { conversationId: conv._id },
      { isDeleted: true, deletedAt: new Date() }
    ).session(session);
  }
  await Conversation.deleteMany({ participants: userId }).session(session);

  await User.findByIdAndDelete(userId).session(session);
};

export const getAllUsers = async (req, res) => {
  try {
    const { status = 'all', search = '' } = req.query;
    const { page, limit, skip } = parsePagination(req.query);

    const filter = {};
    if (status === 'active') {
      filter.isActive = true;
      filter.isSuspended = false;
    }
    if (status === 'suspended') {
      filter.isSuspended = true;
    }
    if (search) {
      const q = escapeRegex(String(search).slice(0, 50));
      filter.$or = [{ email: new RegExp(q, 'i') }, { phone: new RegExp(q, 'i') }];
    }

    const [users, total] = await Promise.all([
      User.find(filter)
        .select('email phone createdAt isActive isSuspended isEmailVerified isPhoneVerified role')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit),
      User.countDocuments(filter),
    ]);

    res.json({
      users,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get all users');
  }
};

export const getUserDetail = async (req, res) => {
  try {
    const { userId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({ message: 'Invalid userId' });
    }

    const user = await User.findById(userId).select(
      '-password -refreshToken -emailVerificationToken -phoneOTP'
    );

    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    const profile = await Profile.findOne({ userId });

    res.json({ user, profile });
  } catch (e) {
    handleControllerError(res, e, 'Get user detail');
  }
};

export const suspendUser = async (req, res) => {
  try {
    const { userId } = req.params;
    const { reason = '' } = req.body;

    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({ message: 'Invalid userId' });
    }

    if (userId === req.user._id.toString()) {
      return res.status(400).json({ message: 'Cannot suspend yourself' });
    }

    const user = await User.findByIdAndUpdate(
      userId,
      {
        isSuspended: true,
        suspensionReason: reason,
        suspensionDate: new Date(),
      },
      { new: true }
    ).select('-password -refreshToken');

    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    await logAdminAction(req, req.user._id, 'user_suspended', userId, reason);

    res.json({ message: 'User suspended successfully', user });
  } catch (e) {
    handleControllerError(res, e, 'Suspend user');
  }
};

export const unsuspendUser = async (req, res) => {
  try {
    const { userId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({ message: 'Invalid userId' });
    }

    const user = await User.findByIdAndUpdate(
      userId,
      {
        isSuspended: false,
        suspensionReason: null,
        suspensionDate: null,
      },
      { new: true }
    ).select('-password -refreshToken');

    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    await logAdminAction(req, req.user._id, 'user_unsuspended', userId);

    res.json({ message: 'User unsuspended successfully', user });
  } catch (e) {
    handleControllerError(res, e, 'Unsuspend user');
  }
};

// ✅ FIX: Full cleanup on deleteUser
export const deleteUser = async (req, res) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const { userId } = req.params;
    const { reason = '' } = req.body;

    if (!mongoose.Types.ObjectId.isValid(userId)) {
      await session.abortTransaction();
      return res.status(400).json({ message: 'Invalid userId' });
    }

    if (userId === req.user._id.toString()) {
      await session.abortTransaction();
      return res.status(400).json({ message: 'Cannot delete yourself' });
    }

    const user = await User.findById(userId).session(session);
    if (!user) {
      await session.abortTransaction();
      return res.status(404).json({ message: 'User not found' });
    }

    await cleanupUserData(userId, session);

    await session.commitTransaction();

    await logAdminAction(req, req.user._id, 'user_deleted', userId, reason);

    res.json({ message: 'User and all associated data deleted successfully' });
  } catch (e) {
    await session.abortTransaction();
    handleControllerError(res, e, 'Delete user');
  } finally {
    session.endSession();
  }
};

export const approveProfile = async (req, res) => {
  try {
    const { profileId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(profileId)) {
      return res.status(400).json({ message: 'Invalid profileId' });
    }

    const profile = await Profile.findByIdAndUpdate(
      profileId,
      {
        isApproved: true,
        approvedAt: new Date(),
        rejectionReason: null,
        rejectionDate: null,
      },
      { new: true }
    );

    if (!profile) {
      return res.status(404).json({ message: 'Profile not found' });
    }

    await logAdminAction(req, req.user._id, 'profile_approved', profile.userId);

    res.json({ message: 'Profile approved successfully', profile });
  } catch (e) {
    handleControllerError(res, e, 'Approve profile');
  }
};

export const rejectProfile = async (req, res) => {
  try {
    const { profileId } = req.params;
    const { reason = '' } = req.body;

    if (!mongoose.Types.ObjectId.isValid(profileId)) {
      return res.status(400).json({ message: 'Invalid profileId' });
    }

    const profile = await Profile.findByIdAndUpdate(
      profileId,
      {
        isApproved: false,
        rejectionReason: reason,
        rejectionDate: new Date(),
      },
      { new: true }
    );

    if (!profile) {
      return res.status(404).json({ message: 'Profile not found' });
    }

    await logAdminAction(req, req.user._id, 'profile_rejected', profile.userId, reason);

    res.json({ message: 'Profile rejected successfully', profile });
  } catch (e) {
    handleControllerError(res, e, 'Reject profile');
  }
};

export const getAllReports = async (req, res) => {
  try {
    const { status = 'pending', reportType = 'all' } = req.query;
    const { page, limit, skip } = parsePagination(req.query);

    const filter = {};
    if (status !== 'all') filter.status = status;
    if (reportType !== 'all') filter.reportType = reportType;

    const [reports, total] = await Promise.all([
      Report.find(filter)
        .populate('reportedUserId', 'email')
        .populate('reportedByUserId', 'email')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit),
      Report.countDocuments(filter),
    ]);

    res.json({
      reports,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get all reports');
  }
};

export const getReportDetail = async (req, res) => {
  try {
    const { reportId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(reportId)) {
      return res.status(400).json({ message: 'Invalid reportId' });
    }

    const report = await Report.findById(reportId)
      .populate('reportedUserId', 'email phone')
      .populate('reportedByUserId', 'email')
      .populate('resolvedBy', 'email');

    if (!report) {
      return res.status(404).json({ message: 'Report not found' });
    }

    res.json(report);
  } catch (e) {
    handleControllerError(res, e, 'Get report detail');
  }
};

// ✅ FIX: Full cleanup on resolveReport deletion action
export const resolveReport = async (req, res) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const { reportId } = req.params;
    const { action = 'none', resolutionNote = '' } = req.body;

    if (!mongoose.Types.ObjectId.isValid(reportId)) {
      await session.abortTransaction();
      return res.status(400).json({ message: 'Invalid reportId' });
    }

    const report = await Report.findById(reportId).session(session);
    if (!report) {
      await session.abortTransaction();
      return res.status(404).json({ message: 'Report not found' });
    }

    report.status = 'resolved';
    report.action = action;
    report.resolvedBy = req.user._id;
    report.resolvedAt = new Date();
    report.resolutionNote = resolutionNote;
    await report.save({ session });

    if (action === 'warning') {
      await logAdminAction(req, req.user._id, 'user_warned', report.reportedUserId, resolutionNote, { reportId });
    } else if (action === 'suspension') {
      await User.findByIdAndUpdate(
        report.reportedUserId,
        {
          isSuspended: true,
          suspensionReason: `Report: ${report.reportType}`,
          suspensionDate: new Date(),
        },
        { session }
      );
      await logAdminAction(req, req.user._id, 'user_suspended', report.reportedUserId, resolutionNote, { reportId });
    } else if (action === 'deletion') {
      // ✅ FIX: Full cleanup instead of just Profile + User
      await cleanupUserData(report.reportedUserId, session);
      await logAdminAction(req, req.user._id, 'user_deleted', report.reportedUserId, resolutionNote, { reportId });
    }

    await session.commitTransaction();

    res.json({ message: 'Report resolved successfully', report });
  } catch (e) {
    await session.abortTransaction();
    handleControllerError(res, e, 'Resolve report');
  } finally {
    session.endSession();
  }
};

export const rejectReport = async (req, res) => {
  try {
    const { reportId } = req.params;
    const { resolutionNote = '' } = req.body;

    if (!mongoose.Types.ObjectId.isValid(reportId)) {
      return res.status(400).json({ message: 'Invalid reportId' });
    }

    const report = await Report.findByIdAndUpdate(
      reportId,
      {
        status: 'rejected',
        resolvedBy: req.user._id,
        resolvedAt: new Date(),
        resolutionNote,
      },
      { new: true }
    );

    if (!report) {
      return res.status(404).json({ message: 'Report not found' });
    }

    await logAdminAction(req, req.user._id, 'report_rejected', report.reportedUserId, resolutionNote, { reportId });

    res.json({ message: 'Report rejected successfully', report });
  } catch (e) {
    handleControllerError(res, e, 'Reject report');
  }
};

export const getDashboardStats = async (req, res) => {
  try {
    const [totalUsers, suspendedUsers, totalProfiles, pendingReports, resolvedReports, recentUsers, reportsByType] =
      await Promise.all([
        User.countDocuments(),
        User.countDocuments({ isSuspended: true }),
        Profile.countDocuments(),
        Report.countDocuments({ status: 'pending' }),
        Report.countDocuments({ status: 'resolved' }),
        User.find().select('email createdAt').sort({ createdAt: -1 }).limit(5),
        Report.aggregate([{ $group: { _id: '$reportType', count: { $sum: 1 } } }]),
      ]);

    res.json({
      stats: {
        totalUsers,
        suspendedUsers,
        activeUsers: totalUsers - suspendedUsers,
        totalProfiles,
        pendingReports,
        resolvedReports,
      },
      recentUsers,
      reportsByType,
    });
  } catch (e) {
    handleControllerError(res, e, 'Get dashboard stats');
  }
};

export const getAdminLogs = async (req, res) => {
  try {
    const { action = 'all' } = req.query;
    const { page, limit, skip } = parsePagination(req.query);

    const filter = {};
    if (action !== 'all') filter.action = action;

    const [logs, total] = await Promise.all([
      AdminLog.find(filter)
        .populate('adminId', 'email')
        .populate('targetUserId', 'email')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit),
      AdminLog.countDocuments(filter),
    ]);

    res.json({
      logs,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get admin logs');
  }
};===== FILE: ./controllers/chatController.js =====
// ===== FIXED FILE: ./controllers/chatController.js =====
import mongoose from 'mongoose';
import Conversation from '../models/Conversation.js';
import Message from '../models/Message.js';
import Profile from '../models/Profile.js';
import User from '../models/User.js'; // ✅ FIX: Added for receiver validation
import { hasPremiumAccess } from '../utils/entitlements.js';
import { handleControllerError } from '../utils/errors.js';
import { parsePagination, formatPaginationResponse } from '../utils/pagination.js';
import { LIMITS } from '../utils/constants.js';

const getUnreadForUser = (unreadCount, userId) => {
  if (!unreadCount || !userId) return 0;
  const key = userId.toString();
  if (typeof unreadCount?.get === 'function') return Number(unreadCount.get(key) || 0);
  if (typeof unreadCount === 'object') return Number(unreadCount[key] || 0);
  if (typeof unreadCount === 'number') return unreadCount;
  return 0;
};

const pickOtherUserId = (participants = [], me) => {
  const meStr = me?.toString?.();
  const other = participants.find((p) => p?.toString?.() !== meStr);
  return other || null;
};

// ✅ FIX: Helper to validate receiver exists and is active
const validateReceiver = async (receiverId) => {
  const receiver = await User.findById(receiverId).select('isSuspended isActive').lean();
  if (!receiver) return { valid: false, message: 'Receiver not found', status: 404 };
  if (receiver.isSuspended) return { valid: false, message: 'Cannot interact with suspended user', status: 400 };
  if (receiver.isActive === false) return { valid: false, message: 'Cannot interact with inactive user', status: 400 };
  return { valid: true };
};

export const getConversations = async (req, res) => {
  try {
    const userId = req.user._id;
    const { page, limit, skip } = parsePagination(req.query);

    const [conversations, total] = await Promise.all([
      Conversation.find({ participants: userId })
        .sort({ updatedAt: -1 })
        .skip(skip)
        .limit(limit)
        .lean(),
      Conversation.countDocuments({ participants: userId }),
    ]);

    const otherUserIds = conversations
      .map((c) => pickOtherUserId(c.participants, userId))
      .filter(Boolean);

    const uniqueOtherIds = [...new Set(otherUserIds.map((x) => x.toString()))].map(
      (id) => new mongoose.Types.ObjectId(id)
    );

    const profiles = uniqueOtherIds.length
      ? await Profile.find({ userId: { $in: uniqueOtherIds } })
          .select('userId fullName photos photoUrl profileId city country')
          .lean()
      : [];

    const profileByUserId = new Map(profiles.map((p) => [p.userId.toString(), p]));

    const formatted = conversations.map((conv) => {
      const otherUserId = pickOtherUserId(conv.participants, userId);
      const profile = otherUserId ? profileByUserId.get(otherUserId.toString()) : null;
      const unreadForMe = getUnreadForUser(conv.unreadCount, userId);

      return {
        ...conv,
        otherUser: profile || (otherUserId ? { userId: otherUserId } : null),
        unreadCount: unreadForMe,
        unreadForMe,
      };
    });

    res.json({
      conversations: formatted,
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get conversations');
  }
};

// ✅ FIX: Validate participant exists and is active
export const getOrCreateConversation = async (req, res) => {
  try {
    const userId = req.user._id;
    const { participantId } = req.params;

    if (!participantId || !mongoose.Types.ObjectId.isValid(participantId)) {
      return res.status(400).json({ message: 'Valid participant ID required' });
    }

    if (participantId.toString() === userId.toString()) {
      return res.status(400).json({ message: 'Cannot create conversation with yourself' });
    }

    // ✅ FIX: Check participant exists and is active
    const receiverCheck = await validateReceiver(participantId);
    if (!receiverCheck.valid) {
      return res.status(receiverCheck.status).json({ message: receiverCheck.message });
    }

    let conversation = await Conversation.findOne({
      participants: { $all: [userId, participantId] },
    });

    if (!conversation) {
      conversation = await Conversation.create({
        participants: [userId, participantId],
        unreadCount: new Map([
          [userId.toString(), 0],
          [participantId.toString(), 0],
        ]),
      });
    } else if (!conversation.unreadCount) {
      conversation.unreadCount = new Map([
        [userId.toString(), 0],
        [participantId.toString(), 0],
      ]);
      await conversation.save();
    }

    const profile = await Profile.findOne({ userId: participantId })
      .select('userId fullName photos photoUrl profileId city country')
      .lean();

    res.json({
      conversation: {
        ...conversation.toObject(),
        otherUser: profile || { userId: participantId },
        unreadCount: getUnreadForUser(conversation.unreadCount, userId),
        unreadForMe: getUnreadForUser(conversation.unreadCount, userId),
      },
    });
  } catch (e) {
    handleControllerError(res, e, 'Get/create conversation');
  }
};

export const getConversation = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(conversationId)) {
      return res.status(400).json({ message: 'Invalid conversationId' });
    }

    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
    });

    if (!conversation) {
      return res.status(404).json({ message: 'Conversation not found' });
    }

    const otherUserId = pickOtherUserId(conversation.participants, userId);

    const profile = otherUserId
      ? await Profile.findOne({ userId: otherUserId })
          .select('userId fullName photos photoUrl profileId city country')
          .lean()
      : null;

    res.json({
      conversation: {
        ...conversation.toObject(),
        otherUser: profile || (otherUserId ? { userId: otherUserId } : null),
        unreadCount: getUnreadForUser(conversation.unreadCount, userId),
        unreadForMe: getUnreadForUser(conversation.unreadCount, userId),
      },
    });
  } catch (e) {
    handleControllerError(res, e, 'Get conversation');
  }
};

export const getMessages = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId } = req.params;
    const { page, limit, skip } = parsePagination(req.query, { defaultLimit: 50 });

    if (!mongoose.Types.ObjectId.isValid(conversationId)) {
      return res.status(400).json({ message: 'Invalid conversationId' });
    }

    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
    });

    if (!conversation) {
      return res.status(404).json({ message: 'Conversation not found' });
    }

    const [messages, total] = await Promise.all([
      Message.find({ conversationId, isDeleted: false })
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .lean(),
      Message.countDocuments({ conversationId, isDeleted: false }),
    ]);

    res.json({
      messages: messages.reverse(),
      pagination: formatPaginationResponse(total, page, limit),
    });
  } catch (e) {
    handleControllerError(res, e, 'Get messages');
  }
};

// ✅ FIX: Validate receiver exists and is active before sending
export const sendMessage = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId, receiverId, content, messageType = 'text' } = req.body;

    const trimmed = typeof content === 'string' ? content.trim() : '';
    if (!trimmed) return res.status(400).json({ message: 'Content is required' });
    if (trimmed.length > LIMITS.MAX_MESSAGE_LENGTH) {
      return res.status(400).json({
        message: `Message too long (max ${LIMITS.MAX_MESSAGE_LENGTH} characters)`,
      });
    }

    if (!hasPremiumAccess(req.user)) {
      return res.status(403).json({ message: 'Premium subscription required', code: 'PREMIUM_REQUIRED' });
    }

    let conversation;

    if (conversationId) {
      if (!mongoose.Types.ObjectId.isValid(conversationId)) {
        return res.status(400).json({ message: 'Invalid conversationId' });
      }
      conversation = await Conversation.findOne({ _id: conversationId, participants: userId });
    } else {
      if (!receiverId || !mongoose.Types.ObjectId.isValid(receiverId)) {
        return res.status(400).json({ message: 'Valid receiverId required' });
      }
      if (receiverId.toString() === userId.toString()) {
        return res.status(400).json({ message: 'Cannot message yourself' });
      }

      // ✅ FIX: Validate receiver
      const receiverCheck = await validateReceiver(receiverId);
      if (!receiverCheck.valid) {
        return res.status(receiverCheck.status).json({ message: receiverCheck.message });
      }

      conversation = await Conversation.findOne({
        participants: { $all: [userId, receiverId] },
      });

      if (!conversation) {
        conversation = await Conversation.create({
          participants: [userId, receiverId],
          unreadCount: new Map([
            [userId.toString(), 0],
            [receiverId.toString(), 0],
          ]),
        });
      }
    }

    if (!conversation) return res.status(404).json({ message: 'Conversation not found' });
    if (conversation.isBlocked) return res.status(403).json({ message: 'Conversation is blocked' });

    const actualReceiverId = pickOtherUserId(conversation.participants, userId);

    const message = await Message.create({
      conversationId: conversation._id,
      senderId: userId,
      receiverId: actualReceiverId,
      content: trimmed,
      messageType,
    });

    conversation.lastMessage = {
      content: trimmed,
      senderId: userId,
      timestamp: new Date(),
      messageType,
    };

    if (!conversation.unreadCount) conversation.unreadCount = new Map();
    const curr = conversation.unreadCount.get(actualReceiverId.toString()) || 0;
    conversation.unreadCount.set(actualReceiverId.toString(), curr + 1);

    await conversation.save();

    res.status(201).json({ message });
  } catch (e) {
    handleControllerError(res, e, 'Send message');
  }
};

export const markAsRead = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(conversationId)) {
      return res.status(400).json({ message: 'Invalid conversationId' });
    }

    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
    });

    if (!conversation) {
      return res.status(404).json({ message: 'Conversation not found' });
    }

    await Message.updateMany(
      { conversationId, receiverId: userId, isRead: false },
      { isRead: true, readAt: new Date() }
    );

    await Conversation.updateOne(
      { _id: conversationId, participants: userId },
      { $set: { [`unreadCount.${userId.toString()}`]: 0 } }
    );

    res.json({ message: 'Marked as read' });
  } catch (e) {
    handleControllerError(res, e, 'Mark as read');
  }
};

export const deleteMessage = async (req, res) => {
  try {
    const userId = req.user._id;
    const { messageId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(messageId)) {
      return res.status(400).json({ message: 'Invalid messageId' });
    }

    const message = await Message.findOne({ _id: messageId, senderId: userId });
    if (!message) return res.status(404).json({ message: 'Message not found' });

    message.isDeleted = true;
    message.deletedAt = new Date();
    await message.save();

    res.json({ message: 'Message deleted' });
  } catch (e) {
    handleControllerError(res, e, 'Delete message');
  }
};

export const deleteConversation = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(conversationId)) {
      return res.status(400).json({ message: 'Invalid conversationId' });
    }

    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
    });

    if (!conversation) return res.status(404).json({ message: 'Conversation not found' });

    await Message.updateMany({ conversationId }, { isDeleted: true, deletedAt: new Date() });
    await conversation.deleteOne();

    res.json({ message: 'Conversation deleted' });
  } catch (e) {
    handleControllerError(res, e, 'Delete conversation');
  }
};

export const getUnreadCount = async (req, res) => {
  try {
    const userId = req.user._id;

    const conversations = await Conversation.find({ participants: userId }).select('unreadCount').lean();

    let total = 0;
    for (const conv of conversations) {
      total += getUnreadForUser(conv.unreadCount, userId);
    }

    res.json({ unreadCount: total });
  } catch (e) {
    handleControllerError(res, e, 'Get unread count');
  }
};

export const blockUser = async (req, res) => {
  try {
    const userId = req.user._id;
    const { userId: targetUserId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(targetUserId)) {
      return res.status(400).json({ message: 'Invalid user ID' });
    }

    // ✅ FIX: Create conversation if needed so block is always recorded
    let conversation = await Conversation.findOne({
      participants: { $all: [userId, targetUserId] },
    });

    if (!conversation) {
      conversation = await Conversation.create({
        participants: [userId, targetUserId],
        isBlocked: true,
        blockedBy: userId,
        unreadCount: new Map([
          [userId.toString(), 0],
          [targetUserId.toString(), 0],
        ]),
      });
    } else {
      conversation.isBlocked = true;
      conversation.blockedBy = userId;
      await conversation.save();
    }

    res.json({ message: 'User blocked' });
  } catch (e) {
    handleControllerError(res, e, 'Block user');
  }
};

export const unblockUser = async (req, res) => {
  try {
    const userId = req.user._id;
    const { userId: targetUserId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(targetUserId)) {
      return res.status(400).json({ message: 'Invalid user ID' });
    }

    const conversation = await Conversation.findOne({
      participants: { $all: [userId, targetUserId] },
      blockedBy: userId,
    });

    if (conversation) {
      conversation.isBlocked = false;
      conversation.blockedBy = undefined;
      await conversation.save();
    }

    res.json({ message: 'User unblocked' });
  } catch (e) {
    handleControllerError(res, e, 'Unblock user');
  }
};

export const getBlockedUsers = async (req, res) => {
  try {
    const userId = req.user._id;

    const conversations = await Conversation.find({
      participants: userId,
      isBlocked: true,
      blockedBy: userId,
    });

    const blockedUserIds = conversations
      .map((conv) => pickOtherUserId(conv.participants, userId))
      .filter(Boolean);

    const profiles = await Profile.find({ userId: { $in: blockedUserIds } })
      .select('fullName photos photoUrl profileId userId')
      .lean();

    res.json({ blockedUsers: profiles });
  } catch (e) {
    handleControllerError(res, e, 'Get blocked users');
  }
};===== FILE: ./package.json =====
{
  "name": "matrimony-server",
  "version": "0.1.0",
  "type": "module",
  "main": "server.js",
  "license": "MIT",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cloudinary": "^2.9.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.6",
    "dotenv": "^16.6.1",
    "express": "^4.22.1",
    "express-rate-limit": "^8.2.1",
    "express-validator": "^7.3.1",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.3",
    "libphonenumber-js": "^1.12.35",
    "mongoose": "^8.22.0",
    "morgan": "^1.10.0",
    "multer": "^2.0.2",
    "slugify": "^1.6.6",
    "socket.io": "^4.8.3",
    "stripe": "^20.3.0",
    "uuid": "^13.0.0"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}===== FILE: ./routes/searchRoutes.js =====
// ===== FILE: ./routes/searchRoutes.js =====
import express from 'express';
import { protect } from '../middleware/authMiddleware.js';
import { handleValidation } from '../middleware/validate.js';
import {
  searchProfilesValidator,
  quickSearchValidator,
  suggestedProfilesValidator,
} from '../validators/searchValidator.js';

import {
  searchProfiles,
  quickSearch,
  getSuggestedProfiles,
  getRecentProfiles,
  searchById,
  getFilterOptions,
} from '../controllers/searchController.js';

const router = express.Router();

// Main search with filters
router.get('/', protect, searchProfilesValidator, handleValidation, searchProfiles);

// Quick search
router.get('/quick', protect, quickSearchValidator, handleValidation, quickSearch);

// Suggested profiles
router.get('/suggested', protect, suggestedProfilesValidator, handleValidation, getSuggestedProfiles);

// Recent profiles
router.get('/recent', protect, getRecentProfiles);

// Filter options
router.get('/filters/options', protect, getFilterOptions);

// Search by profile ID
router.get('/by-id/:profileId', protect, searchById);

export default router;===== FILE: ./routes/paymentRoutes.js =====
// ===== FILE: ./routes/paymentRoutes.js =====
import { Router } from 'express';
import { protect } from '../middleware/authMiddleware.js';  // ✅ Changed from auth.js
import {
  unlockContact,
  isContactUnlocked,
  getUnlockedContacts,
  getContactDetails,
  getPaymentHistory,
  getPaymentById,
} from '../controllers/paymentController.js';

const router = Router();

// Unlock contact endpoints
router.post('/unlock-contact', protect, unlockContact);
router.post('/unlock-contact/:targetUserId', protect, unlockContact);

// Check if contact is unlocked
router.get('/is-unlocked/:targetUserId', protect, isContactUnlocked);

// Get all unlocked contacts
router.get('/unlocked-contacts', protect, getUnlockedContacts);

// Get contact details (requires unlock or premium)
router.get('/contact/:targetUserId', protect, getContactDetails);

// Payment history
router.get('/history', protect, getPaymentHistory);
router.get('/:paymentId', protect, getPaymentById);

export default router;===== FILE: ./routes/subscriptionRoutes.js =====
// ===== FIXED FILE: ./routes/subscriptionRoutes.js =====
import express from 'express';
import { protect, optionalAuth } from '../middleware/authMiddleware.js'; // ✅ FIX: Added optionalAuth
import {
  getPlans,
  getMySubscription,
  createCheckoutSession,
  createPaymentIntent,
  verifyPayment,
  cancelSubscription,
  getPaymentHistory,
  checkFeatureAccess,
  handleWebhook,
} from '../controllers/subscriptionController.js';

const router = express.Router();

// Stripe webhook (NO auth)
router.post('/webhook', handleWebhook);

// ✅ FIX: Use optionalAuth so getPlans can read req.user if logged in
router.get('/plans', optionalAuth, getPlans);

// Protected
router.get('/my-subscription', protect, getMySubscription);
router.post('/create-checkout', protect, createCheckoutSession);
router.post('/create-payment-intent', protect, createPaymentIntent);
router.post('/verify', protect, verifyPayment);
router.post('/cancel', protect, cancelSubscription);
router.get('/history', protect, getPaymentHistory);
router.get('/check-feature/:feature', protect, checkFeatureAccess);

export default router;===== FILE: ./routes/adminRoutes.js =====
// ===== FILE: ./routes/adminRoutes.js =====
import { Router } from 'express';
import { protect, admin } from '../middleware/authMiddleware.js';  // ✅ Changed from auth.js
import { handleValidation } from '../middleware/validate.js';
import {
  suspendUserValidator,
  resolveReportValidator,
  paginationValidator,
} from '../validators/adminValidator.js';
import {
  getAllUsers,
  getUserDetail,
  suspendUser,
  unsuspendUser,
  deleteUser,
  approveProfile,
  rejectProfile,
  getAllReports,
  getReportDetail,
  resolveReport,
  rejectReport,
  getDashboardStats,
  getAdminLogs,
} from '../controllers/adminController.js';

import {
  listPlans,
  createPlan,
  updatePlan,
  togglePlan,
  deletePlan,
  reorderPlans,
} from '../controllers/adminPlanController.js';

const router = Router();

// ============================================
// USER MANAGEMENT
// ============================================

router.get('/users', protect, admin, paginationValidator, handleValidation, getAllUsers);
router.get('/users/:userId', protect, admin, getUserDetail);
router.put('/users/:userId/suspend', protect, admin, suspendUserValidator, handleValidation, suspendUser);
router.put('/users/:userId/unsuspend', protect, admin, unsuspendUser);
router.delete('/users/:userId', protect, admin, deleteUser);

// ============================================
// PROFILE MANAGEMENT
// ============================================

router.put('/profiles/:profileId/approve', protect, admin, approveProfile);
router.put('/profiles/:profileId/reject', protect, admin, rejectProfile);

// ============================================
// REPORT MANAGEMENT
// ============================================

router.get('/reports', protect, admin, paginationValidator, handleValidation, getAllReports);
router.get('/reports/:reportId', protect, admin, getReportDetail);
router.put('/reports/:reportId/resolve', protect, admin, resolveReportValidator, handleValidation, resolveReport);
router.put('/reports/:reportId/reject', protect, admin, rejectReport);

// ============================================
// DASHBOARD & LOGS
// ============================================

router.get('/dashboard/stats', protect, admin, getDashboardStats);
router.get('/logs', protect, admin, paginationValidator, handleValidation, getAdminLogs);

// ============================================
// PLANS MANAGEMENT
// ============================================

router.get('/plans', protect, admin, listPlans);
router.post('/plans', protect, admin, createPlan);
router.put('/plans/reorder', protect, admin, reorderPlans);
router.put('/plans/:planId', protect, admin, updatePlan);
router.patch('/plans/:planId/toggle', protect, admin, togglePlan);
router.delete('/plans/:planId', protect, admin, deletePlan);

export default router;===== FILE: ./routes/profileRoutes.js =====
// ===== UPDATED FILE: ./routes/profileRoutes.js =====
import express from 'express';
import { protect, optionalAuth } from '../middleware/authMiddleware.js';
import { handleValidation } from '../middleware/validate.js';
import { createProfileValidator, updateProfileValidator } from '../validators/commonValidator.js';
import {
  getMyProfile,
  createProfile,
  updateProfile,
  deleteProfile,
  getCompletion,
  getProfileById,
  uploadPhotos,
  deletePhoto,
  setProfilePhoto,
  updatePartnerPreferences,
  updatePrivacySettings,
} from '../controllers/profileController.js';
import upload from '../middleware/uploadMiddleware.js';

const router = express.Router();

// Profile CRUD
router.get('/', protect, getMyProfile);
router.post('/', protect, createProfileValidator, handleValidation, createProfile);
router.put('/', protect, updateProfileValidator, handleValidation, updateProfile);
router.delete('/', protect, deleteProfile);

// Profile completion
router.get('/completion', protect, getCompletion);

// Photos
router.post('/photos', protect, upload.array('photos', 6), uploadPhotos);
router.delete('/photos/:photoId', protect, deletePhoto);
router.put('/photos/:photoId/profile', protect, setProfilePhoto);

// Partner preferences
router.put('/partner-preferences', protect, updatePartnerPreferences);

// Privacy settings
router.put('/privacy-settings', protect, updatePrivacySettings);

// Get profile by ID (public with optional auth)
router.get('/:profileId', optionalAuth, getProfileById);

export default router;===== FILE: ./routes/chatRoutes.js =====
// ===== FILE: ./routes/chatRoutes.js =====
import express from 'express';
import { protect } from '../middleware/authMiddleware.js';
import {
  getConversations,
  getOrCreateConversation,  // ✅ Correct
  getConversation,
  getMessages,
  sendMessage,
  markAsRead,
  deleteMessage,
  deleteConversation,
  getUnreadCount,
  blockUser,
  unblockUser,
  getBlockedUsers,
} from '../controllers/chatController.js';

const router = express.Router();

// Get all conversations
router.get('/', protect, getConversations);

// Get unread count
router.get('/unread-count', protect, getUnreadCount);

// Get blocked users
router.get('/blocked', protect, getBlockedUsers);

// Get or create conversation with a user
router.get('/with/:participantId', protect, getOrCreateConversation);

// Get single conversation
router.get('/:conversationId', protect, getConversation);

// Get messages in a conversation
router.get('/:conversationId/messages', protect, getMessages);

// Send message
router.post('/message', protect, sendMessage);

// Delete message
router.delete('/message/:messageId', protect, deleteMessage);

// Mark conversation as read
router.put('/:conversationId/read', protect, markAsRead);

// Delete conversation
router.delete('/:conversationId', protect, deleteConversation);

// Block/Unblock
router.post('/block/:userId', protect, blockUser);
router.post('/unblock/:userId', protect, unblockUser);

export default router;===== FILE: ./routes/notificationRoutes.js =====
// ===== FILE: ./routes/notificationRoutes.js =====
import express from 'express';
import { protect } from '../middleware/authMiddleware.js';
import {
  getNotifications,
  getUnreadCount,
  markAsRead,
  markAllAsRead,
  deleteNotification,
  deleteAllNotifications,
} from '../controllers/notificationController.js';

const router = express.Router();

// Get all notifications
router.get('/', protect, getNotifications);

// Get unread count
router.get('/unread-count', protect, getUnreadCount);

// Mark single notification as read
router.put('/:id/read', protect, markAsRead);

// Mark all as read
router.put('/read-all', protect, markAllAsRead);

// Delete single notification
router.delete('/:id', protect, deleteNotification);

// Delete all notifications
router.delete('/', protect, deleteAllNotifications);

export default router;===== FILE: ./routes/authRoutes.js =====
// ===== FILE: ./routes/authRoutes.js =====
import express from 'express';
import { protect } from '../middleware/authMiddleware.js';
import { handleValidation } from '../middleware/validate.js';
import { registerValidator, loginValidator } from '../validators/authValidator.js';
import {
  register,
  login,
  logout,
  getMe,
  refreshToken,
  sendEmailOtp,
  verifyEmail,
  forgotPassword,
  resetPassword,
  changePassword,
  deleteAccount,
} from '../controllers/authController.js';

const router = express.Router();

// ============================================
// PUBLIC ROUTES
// ============================================

// Registration & Login
router.post('/register', registerValidator, handleValidation, register);
router.post('/login', loginValidator, handleValidation, login);
router.post('/logout', logout);

// Token refresh
router.post('/refresh-token', refreshToken);

// Email verification
router.post('/send-email-otp', sendEmailOtp);
router.get('/verify-email/:token', verifyEmail);

// Password reset
router.post('/forgot-password', forgotPassword);
router.post('/reset-password/:token', resetPassword);

// ============================================
// PROTECTED ROUTES
// ============================================

// Get current user
router.get('/me', protect, getMe);

// Change password (must be logged in)
router.post('/change-password', protect, changePassword);

// Delete account (must be logged in)
router.delete('/delete-account', protect, deleteAccount);

export default router;===== FILE: ./routes/reportRoutes.js =====
// ===== FILE: ./routes/reportRoutes.js =====
import { Router } from 'express';
import { protect } from '../middleware/authMiddleware.js';  // ✅ Changed from auth.js
import { handleValidation } from '../middleware/validate.js';
import { reportValidator } from '../validators/commonValidator.js';
import {
  createReport,
  getMyReports,
  getReportStatus,
  getMyReportStats,
} from '../controllers/reportController.js';

const router = Router();

// Create a new report
router.post('/', protect, reportValidator, handleValidation, createReport);

// Get user's submitted reports
router.get('/my-reports', protect, getMyReports);

// Get report statistics
router.get('/my-stats', protect, getMyReportStats);

// Get specific report status
router.get('/:reportId/status', protect, getReportStatus);

export default router;===== FILE: ./routes/interestRoutes.js =====
// ===== FILE: ./routes/interestRoutes.js =====
import express from 'express';
import { protect } from '../middleware/authMiddleware.js';
import { handleValidation } from '../middleware/validate.js';
import { interestValidator, userIdParamValidator, mongoIdValidator } from '../validators/commonValidator.js';
import {
  sendInterest,
  acceptInterest,
  declineInterest,
  blockInterest,
  withdrawInterest,
  getInterestsSent,
  getInterestsReceived,
  getAcceptedInterests,
  getDeclinedInterests,
  getMutualInterests,
  getInterestStatus,
  getShortlist,
  addToShortlist,
  removeFromShortlist,
  isShortlisted,
  updateShortlistNote,
} from '../controllers/interestController.js';

const router = express.Router();

// ============================================
// INTEREST ROUTES
// ============================================

// Send new interest
router.post('/', protect, interestValidator, handleValidation, sendInterest);

// Get interests
router.get('/sent', protect, getInterestsSent);
router.get('/received', protect, getInterestsReceived);
router.get('/accepted', protect, getAcceptedInterests);
router.get('/declined', protect, getDeclinedInterests);
router.get('/mutual', protect, getMutualInterests);

// Get interest status with specific user
router.get('/status/:userId', protect, userIdParamValidator, handleValidation, getInterestStatus);

// Interest actions
router.put('/:id/accept', protect, mongoIdValidator, handleValidation, acceptInterest);
router.put('/:id/decline', protect, mongoIdValidator, handleValidation, declineInterest);
router.put('/:id/block', protect, mongoIdValidator, handleValidation, blockInterest);
router.delete('/:id', protect, mongoIdValidator, handleValidation, withdrawInterest);

// ============================================
// SHORTLIST ROUTES
// ============================================

router.get('/shortlist', protect, getShortlist);
router.get('/shortlist/check/:userId', protect, userIdParamValidator, handleValidation, isShortlisted);
router.post('/shortlist/:userId', protect, userIdParamValidator, handleValidation, addToShortlist);
router.put('/shortlist/:userId/note', protect, userIdParamValidator, handleValidation, updateShortlistNote);
router.delete('/shortlist/:userId', protect, userIdParamValidator, handleValidation, removeFromShortlist);

export default router;===== FILE: ./server.js =====
// ===== FIXED FILE: ./server.js =====
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import cookieParser from 'cookie-parser';
import dotenv from 'dotenv';
import mongoose from 'mongoose';
import { createServer } from 'http';
import { Server } from 'socket.io';

import { apiLimiter, authLimiter } from './middleware/rateLimiter.js';
import errorHandler from './middleware/errorHandler.js';
import socketHandler from './socket/socketHandler.js';

import authRoutes from './routes/authRoutes.js';
import profileRoutes from './routes/profileRoutes.js';
import searchRoutes from './routes/searchRoutes.js';
import interestRoutes from './routes/interestRoutes.js';
import chatRoutes from './routes/chatRoutes.js';
import subscriptionRoutes from './routes/subscriptionRoutes.js';
import paymentRoutes from './routes/paymentRoutes.js';
import reportRoutes from './routes/reportRoutes.js';
import adminRoutes from './routes/adminRoutes.js';
import notificationRoutes from './routes/notificationRoutes.js';

dotenv.config();

const app = express();
const httpServer = createServer(app);

const io = new Server(httpServer, {
  cors: { origin: process.env.CLIENT_URL || 'http://localhost:5173', credentials: true },
});

const socketInstance = socketHandler(io);
app.set('io', io);
app.set('socketInstance', socketInstance);

app.use(helmet());
app.use(cors({ origin: process.env.CLIENT_URL || 'http://localhost:5173', credentials: true }));

app.use('/uploads', express.static('uploads'));

app.use(
  express.json({
    limit: '10mb',
    verify: (req, _res, buf) => {
      if (req.originalUrl && req.originalUrl.startsWith('/api/subscriptions/webhook')) {
        req.rawBody = buf;
      }
    },
  })
);
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(cookieParser());

if (process.env.NODE_ENV !== 'production') app.use(morgan('dev'));

const isDev = process.env.NODE_ENV !== 'production';
if (!isDev) app.use('/api', apiLimiter);

app.use('/api/auth/login', authLimiter);
app.use('/api/auth/register', authLimiter);
app.use('/api/auth/forgot-password', authLimiter);

app.get('/api/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
  });
});

app.use('/api/auth', authRoutes);
app.use('/api/profile', profileRoutes);
app.use('/api/search', searchRoutes);
app.use('/api/interests', interestRoutes);
app.use('/api/chat', chatRoutes);
app.use('/api/subscriptions', subscriptionRoutes);
app.use('/api/payments', paymentRoutes);
app.use('/api/reports', reportRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api/notifications', notificationRoutes);

app.use((req, res) => {
  res.status(404).json({ message: `Route ${req.method} ${req.path} not found` });
});

app.use(errorHandler);

const PORT = process.env.PORT || 5000;
const MONGODB_URI =
  process.env.MONGODB_URI || process.env.MONGO_URI || 'mongodb://localhost:27017/matrimony';

mongoose.set('strictQuery', false);

mongoose
  .connect(MONGODB_URI)
  .then(() => {
    console.log('✅ MongoDB connected successfully');
    httpServer.listen(PORT, () => {
      console.log(`✅ Server running on port ${PORT}`);
      console.log(`✅ Environment: ${process.env.NODE_ENV || 'development'}`);
      console.log(`✅ Client URL: ${process.env.CLIENT_URL || 'http://localhost:5173'}`);
    });
  })
  .catch((err) => {
    console.error('❌ MongoDB connection error:', err);
    process.exit(1);
  });

// ✅ FIX: Single shutdown handler — no double cleanup
const shutdown = async (signal) => {
  console.log(`${signal} received. Shutting down gracefully...`);
  socketInstance?.cleanup?.();
  httpServer.close(async () => {
    try {
      // ✅ FIX: Use promise-based close for Mongoose 8.x
      await mongoose.connection.close();
      console.log('Server closed.');
    } catch (e) {
      console.error('Error closing MongoDB connection:', e.message);
    }
    process.exit(0);
  });

  // Force exit after 10s if graceful fails
  setTimeout(() => {
    console.error('Forced shutdown after timeout');
    process.exit(1);
  }, 10000);
};

process.on('SIGTERM', () => shutdown('SIGTERM'));
process.on('SIGINT', () => shutdown('SIGINT'));

export { io };
export default app;===== FILE: ./models/AdminLog.js =====
import mongoose from 'mongoose';

const adminLogSchema = new mongoose.Schema(
  {
    adminId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    action: {
      type: String,
      enum: [
        'user_suspended',
        'user_unsuspended',
        'user_deleted',
        'profile_approved',
        'profile_rejected',
        'profile_deleted',
        'report_resolved',
        'report_rejected', // ADDED: New action for rejecting reports
        'fake_profile_marked',
        'inappropriate_content_removed',
        'user_warned',
        'feature_toggled',

        // plans
        'plan_created',
        'plan_updated',
        // 'plan_deleted', // REMOVED: Use 'plan_deleted_soft' instead
        'plan_activated',
        'plan_deactivated',
        'plan_deleted_soft',
        'plans_reordered',
      ],
      required: true,
    },
    targetUserId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    targetProfileId: { type: mongoose.Schema.Types.ObjectId, ref: 'Profile' },
    reportId: { type: mongoose.Schema.Types.ObjectId, ref: 'Report' },
    reason: { type: String, default: null },
    metadata: { type: mongoose.Schema.Types.Mixed, default: {} },
    ipAddress: String,
    userAgent: String,
  },
  { timestamps: true }
);

adminLogSchema.index({ adminId: 1, createdAt: -1 });
adminLogSchema.index({ action: 1, createdAt: -1 });
adminLogSchema.index({ targetUserId: 1 });

export default mongoose.model('AdminLog', adminLogSchema);===== FILE: ./models/Report.js =====
import mongoose from 'mongoose';

const reportSchema = new mongoose.Schema(
  {
    reportedUserId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    reportedByUserId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    reportType: {
      type: String,
      enum: [
        'fake_profile','inappropriate_behavior','harassment','inappropriate_content',
        'scam','offensive_language','other',
      ],
      required: true,
    },
    description: { type: String, required: true, maxlength: 500 },
    evidence: { type: [String], default: [] },
    status: {
      type: String,
      enum: ['pending','under_review','resolved','rejected','dismissed'],
      default: 'pending',
    },
    resolutionNote: String,
    action: { type: String, enum: ['none','warning','suspension','deletion'], default: 'none' },
    resolvedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    resolvedAt: Date,
  },
  { timestamps: true }
);

reportSchema.index({ reportedUserId: 1, status: 1 });
reportSchema.index({ reportedByUserId: 1 });
reportSchema.index({ reportType: 1 });
reportSchema.index({ status: 1, createdAt: -1 });

export default mongoose.model('Report', reportSchema);===== FILE: ./models/User.js =====
// server/models/User.js
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';

const { Schema, model } = mongoose;

const userSchema = new Schema(
  {
    email: {
      type: String,
      unique: true,
      sparse: true,
      lowercase: true,
      trim: true,
    },
    phone: {
      type: String,
      trim: true,
      unique: true,
      sparse: true,
    },
    countryCode: { type: String, default: '+91' },

    password: { type: String, required: true, minlength: 6 },

    fullName: { type: String, trim: true },
    profileId: { type: Schema.Types.ObjectId, ref: 'Profile' },

    role: {
      type: String,
      enum: ['user', 'admin', 'moderator', 'superadmin'],
      default: 'user',
    },

    isActive: { type: Boolean, default: true },
    isSuspended: { type: Boolean, default: false },
    suspensionReason: { type: String },
    suspensionDate: { type: Date },

    isVerified: { type: Boolean, default: false },
    isEmailVerified: { type: Boolean, default: false },
    isPhoneVerified: { type: Boolean, default: false },

    isPremium: { type: Boolean, default: false },
    premiumExpiry: { type: Date },

    subscription: {
      plan: { type: String, enum: ['free', 'monthly', 'yearly'], default: 'free' },
      startDate: Date,
      endDate: Date,
      isActive: { type: Boolean, default: false },
    },

    subscriptionId: { type: Schema.Types.ObjectId, ref: 'Subscription' },

    refreshToken: { type: String },
    emailVerificationToken: String,
    emailVerificationExpiry: Date,

    passwordResetToken: String,
    passwordResetExpiry: Date,

    contactsUnlocked: [{ type: Schema.Types.ObjectId, ref: 'User' }],

    lastLogin: { type: Date },
    lastActive: { type: Date, default: Date.now },
    isOnline: { type: Boolean, default: false },
    socketId: { type: String },

    loginAttempts: { type: Number, default: 0 },
    lockUntil: Date,
  },
  { timestamps: true }
);

userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

userSchema.methods.comparePassword = async function (candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

userSchema.methods.isLocked = function () {
  return this.lockUntil && this.lockUntil > Date.now();
};

export default model('User', userSchema);===== FILE: ./models/Subscription.js =====
// ===== FILE: ./models/Subscription.js =====
import mongoose from 'mongoose';
const { Schema } = mongoose;

const subscriptionSchema = new Schema(
  {
    // -------------------------------------------------
    // Core relationship
    // -------------------------------------------------
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      unique: true,
    },

    // -------------------------------------------------
    // Plan & status
    // -------------------------------------------------
    plan: {
      type: String,
      enum: ['free', 'monthly', 'yearly'],
      default: 'free',
    },

    status: {
      type: String,
      enum: ['active', 'cancelled', 'expired', 'past_due', 'trialing'],
      default: 'active',
    },

    // -------------------------------------------------
    // Stripe identifiers (optional – only for paid plans)
    // -------------------------------------------------
    stripeCustomerId: String,
    stripeSubscriptionId: String,
    stripePriceId: String,
    stripePaymentMethodId: String,

    // -------------------------------------------------
    // Pricing info (mirrors Stripe for reporting)
    // -------------------------------------------------
    currency: { type: String, default: 'USD' },
    amount: { type: Number, default: 0 },

    // -------------------------------------------------
    // Dates
    // -------------------------------------------------
    startDate: { type: Date, default: Date.now },
    endDate: Date,          // calculated by Stripe or by us when we create the sub
    cancelledAt: Date,      // when user requested cancel‑at‑period‑end
    trialEndDate: Date,

    // -------------------------------------------------
    // Renewal control
    // -------------------------------------------------
    autoRenew: { type: Boolean, default: true }, // false → cancel_at_period_end
    renewalReminded: { type: Boolean, default: false },

    // -------------------------------------------------
    // Feature flags – always derived from `plan`
    // -------------------------------------------------
    features: {
      unlimitedMessages: { type: Boolean, default: false },
      seeWhoLikedYou: { type: Boolean, default: false },
      advancedFilters: { type: Boolean, default: false },
      prioritySupport: { type: Boolean, default: false },
      profileBoost: { type: Boolean, default: false },
      unlimitedLikes: { type: Boolean, default: false },
      readReceipts: { type: Boolean, default: false },
      noAds: { type: Boolean, default: false },
    },
  },
  {
    // Mongoose will automatically add `createdAt` and `updatedAt`
    timestamps: true,
  }
);

/* -----------------------------------------------------------------
   Indexes – keep look‑ups fast
   ----------------------------------------------------------------- */
subscriptionSchema.index({ userId: 1 });
subscriptionSchema.index({ stripeCustomerId: 1 });
subscriptionSchema.index({ stripeSubscriptionId: 1 });
subscriptionSchema.index({ status: 1 });
subscriptionSchema.index({ endDate: 1 });

/* -----------------------------------------------------------------
   Helper: set feature flags based on the current plan
   ----------------------------------------------------------------- */
subscriptionSchema.methods.setFeaturesByPlan = function () {
  if (this.plan === 'free') {
    this.features = {
      unlimitedMessages: false,
      seeWhoLikedYou: false,
      advancedFilters: false,
      prioritySupport: false,
      profileBoost: false,
      unlimitedLikes: false,
      readReceipts: false,
      noAds: false,
    };
  } else {
    // monthly & yearly get all features, with extra perks for yearly
    this.features = {
      unlimitedMessages: true,
      seeWhoLikedYou: true,
      advancedFilters: true,
      prioritySupport: this.plan === 'yearly',
      profileBoost: this.plan === 'yearly',
      unlimitedLikes: true,
      readReceipts: true,
      noAds: true,
    };
  }
};

/* -----------------------------------------------------------------
   Helper: is the subscription currently active?
   ----------------------------------------------------------------- */
subscriptionSchema.methods.isActive = function () {
  // Free plan is always active (no expiry)
  if (this.plan === 'free') return true;

  // Status must be active or trialing
  if (this.status !== 'active' && this.status !== 'trialing') return false;

  // If an endDate exists, it must be in the future
  if (this.endDate && new Date() > this.endDate) return false;

  // All other checks passed → active
  return true;
};

/* -----------------------------------------------------------------
   Pre‑save hook – keep feature flags in sync whenever the plan
   changes (or on first creation).
   ----------------------------------------------------------------- */
subscriptionSchema.pre('save', function (next) {
  // `isModified('plan')` catches both new docs and plan changes
  if (this.isNew || this.isModified('plan')) {
    this.setFeaturesByPlan();
  }
  next();
});

export default mongoose.model('Subscription', subscriptionSchema);===== FILE: ./models/Message.js =====
import mongoose from 'mongoose';
const { Schema } = mongoose;

const messageSchema = new Schema({
  conversationId: { 
    type: Schema.Types.ObjectId, 
    ref: 'Conversation', 
    required: true 
  },
  senderId: { 
    type: Schema.Types.ObjectId, 
    ref: 'User', 
    required: true 
  },
  receiverId: { 
    type: Schema.Types.ObjectId, 
    ref: 'User', 
    required: true 
  },
  content: { type: String, required: true, maxlength: 2000 },
  messageType: {
    type: String,
    enum: ['text', 'image', 'file', 'system'],
    default: 'text',
  },
  isRead: { type: Boolean, default: false },
  readAt: Date,
  isDeleted: { type: Boolean, default: false },
  deletedAt: Date,
  
  createdAt: { type: Date, default: Date.now },
});

messageSchema.index({ conversationId: 1, createdAt: -1 });
messageSchema.index({ senderId: 1 });
messageSchema.index({ receiverId: 1, isRead: 1 });

export default mongoose.model('Message', messageSchema);===== FILE: ./models/Plan.js =====
import mongoose from 'mongoose';

const PlanSchema = new mongoose.Schema(
  {
    name: { type: String, required: true, trim: true },
    slug: { type: String, required: true, unique: true, lowercase: true, trim: true },
    description: { type: String, default: '' },

    // multi-currency
    price: { type: Object, required: true },         // ex: { INR: 999, USD: 12 }
    discountPrice: { type: Object, default: undefined },

    duration: {
      value: { type: Number, required: true },
      unit: { type: String, required: true, enum: ['days', 'months', 'years'] },
    },

    features: { type: Object, default: {} },

    recommended: { type: Boolean, default: false },
    isActive: { type: Boolean, default: true },
    sortOrder: { type: Number, default: 0 },
  },
  { timestamps: true }
);

export default mongoose.model('Plan', PlanSchema);===== FILE: ./models/Conversation.js =====
// ===== FILE: ./models/Conversation.js =====
import mongoose from 'mongoose';
const { Schema } = mongoose;

const conversationSchema = new Schema({
  participants: [
    {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
  ],
  lastMessage: {
    content: String,
    senderId: { type: Schema.Types.ObjectId, ref: 'User' },
    timestamp: Date,
    messageType: { type: String, default: 'text' },
  },
  unreadCount: {
    type: Map,
    of: Number,
    default: new Map(),
  },
  isBlocked: { type: Boolean, default: false },
  blockedBy: { type: Schema.Types.ObjectId, ref: 'User' },

  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }, // ✅ ensure it exists for sorting
});

conversationSchema.index({ participants: 1 });
conversationSchema.index({ updatedAt: -1 });

conversationSchema.pre('save', function (next) {
  this.updatedAt = new Date();
  next();
});

export default mongoose.model('Conversation', conversationSchema);===== FILE: ./models/Notification.js =====
// ===== FILE: ./models/Notification.js =====
import mongoose from 'mongoose';

const notificationSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      index: true,
    },
    type: {
      type: String,
      enum: [
        'interest_received',
        'interest_accepted',
        'interest_declined',
        'new_message',
        'profile_view',
        'match',
        'subscription',
        'system',
      ],
      required: true,
    },
    title: {
      type: String,
      required: true,
      maxlength: 100,
    },
    message: {
      type: String,
      required: true,
      maxlength: 500,
    },
    read: {
      type: Boolean,
      default: false,
    },
    readAt: Date,
    
    // Related entity references
    relatedUserId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
    },
    relatedProfileId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Profile',
    },
    relatedInterestId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Interest',
    },
    relatedConversationId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Conversation',
    },
    
    // Action URL
    actionUrl: String,
    
    // Extra data
    metadata: {
      type: mongoose.Schema.Types.Mixed,
      default: {},
    },
  },
  {
    timestamps: true,
  }
);

// Indexes
notificationSchema.index({ userId: 1, read: 1 });
notificationSchema.index({ userId: 1, createdAt: -1 });
notificationSchema.index({ type: 1 });

// Auto-delete old notifications (optional - run via cron)
notificationSchema.statics.cleanOldNotifications = async function (daysOld = 30) {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - daysOld);
  
  return this.deleteMany({
    createdAt: { $lt: cutoffDate },
    read: true,
  });
};

export default mongoose.model('Notification', notificationSchema);===== FILE: ./models/Interest.js =====
// ===== FILE: ./models/Interest.js =====

import mongoose from 'mongoose';
const { Schema } = mongoose;

const interestSchema = new Schema({
  senderId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Sender ID is required'],
  },
  receiverId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Receiver ID is required'],
  },
  senderProfileId: {
    type: Schema.Types.ObjectId,
    ref: 'Profile',
  },
  receiverProfileId: {
    type: Schema.Types.ObjectId,
    ref: 'Profile',
  },
  status: {
    type: String,
    enum: {
      values: ['pending', 'accepted', 'declined', 'blocked', 'withdrawn'],
      message: 'Status must be: pending, accepted, declined, blocked, or withdrawn',
    },
    default: 'pending',
  },
  message: {
    type: String,
    maxlength: [200, 'Message cannot exceed 200 characters'],
    trim: true,
  },
  declineReason: {
    type: String,
    maxlength: [500, 'Decline reason cannot exceed 500 characters'],
    trim: true,
  },

  respondedAt: Date,

  createdAt: { type: Date, default: Date.now },
  updatedAt: Date,
});

// Prevent duplicate interests (compound unique index)
interestSchema.index({ senderId: 1, receiverId: 1 }, { unique: true });

// Indexes for common queries
interestSchema.index({ receiverId: 1, status: 1 });
interestSchema.index({ senderId: 1, status: 1 });
interestSchema.index({ createdAt: -1 });
interestSchema.index({ status: 1, respondedAt: -1 });

// Pre-save middleware
interestSchema.pre('save', function (next) {
  // Prevent self-interest at database level
  if (this.senderId && this.receiverId) {
    if (this.senderId.toString() === this.receiverId.toString()) {
      const error = new Error('Cannot send interest to yourself');
      error.name = 'ValidationError';
      return next(error);
    }
  }

  this.updatedAt = new Date();
  next();
});

// Pre-validate middleware (runs before save)
interestSchema.pre('validate', function (next) {
  // Ensure senderId and receiverId are different
  if (this.senderId && this.receiverId) {
    if (this.senderId.equals(this.receiverId)) {
      this.invalidate('receiverId', 'Cannot send interest to yourself');
    }
  }
  next();
});

// Static method to check if interest exists between two users
interestSchema.statics.existsBetween = async function (userA, userB) {
  const interest = await this.findOne({
    $or: [
      { senderId: userA, receiverId: userB },
      { senderId: userB, receiverId: userA },
    ],
  });
  return interest;
};

// Static method to check if mutual interest (both accepted)
interestSchema.statics.isMutualMatch = async function (userA, userB) {
  const interests = await this.find({
    $or: [
      { senderId: userA, receiverId: userB, status: 'accepted' },
      { senderId: userB, receiverId: userA, status: 'accepted' },
    ],
  });

  // Both directions must be accepted for mutual match
  return interests.length === 2;
};

// Instance method to check if interest can be modified
interestSchema.methods.canBeModifiedBy = function (userId) {
  const userIdStr = userId.toString();
  const isReceiver = this.receiverId.toString() === userIdStr;
  const isSender = this.senderId.toString() === userIdStr;

  return {
    canAccept: isReceiver && this.status === 'pending',
    canDecline: isReceiver && this.status === 'pending',
    canBlock: isReceiver,
    canWithdraw: isSender && this.status === 'pending',
  };
};

// Virtual for age of interest
interestSchema.virtual('ageInDays').get(function () {
  if (!this.createdAt) return 0;
  const now = new Date();
  const diffMs = now - this.createdAt;
  return Math.floor(diffMs / (1000 * 60 * 60 * 24));
});

// Virtual for response time (if responded)
interestSchema.virtual('responseTimeHours').get(function () {
  if (!this.respondedAt || !this.createdAt) return null;
  const diffMs = this.respondedAt - this.createdAt;
  return Math.round(diffMs / (1000 * 60 * 60));
});

interestSchema.set('toJSON', { virtuals: true });
interestSchema.set('toObject', { virtuals: true });

export default mongoose.model('Interest', interestSchema);===== FILE: ./models/Shortlist.js =====
import mongoose from 'mongoose';
const { Schema } = mongoose;

const shortlistSchema = new Schema({
  userId: { 
    type: Schema.Types.ObjectId, 
    ref: 'User', 
    required: true 
  },
  shortlistedUserId: { 
    type: Schema.Types.ObjectId, 
    ref: 'User', 
    required: true 
  },
  shortlistedProfileId: { 
    type: Schema.Types.ObjectId, 
    ref: 'Profile' 
  },
  note: { type: String, maxlength: 500 },
  createdAt: { type: Date, default: Date.now },
});

shortlistSchema.index({ userId: 1, shortlistedUserId: 1 }, { unique: true });
shortlistSchema.index({ userId: 1, createdAt: -1 });

export default mongoose.model('Shortlist', shortlistSchema);===== FILE: ./models/Profile.js =====
// ===== FIXED FILE: server/models/Profile.js =====
import mongoose from 'mongoose';

const { Schema, model } = mongoose;

const photoSchema = new Schema({
  url: { type: String, required: true },
  publicId: { type: String },
  isProfile: { type: Boolean, default: false },
  uploadedAt: { type: Date, default: Date.now },
});

const profileSchema = new Schema(
  {
    userId: { type: Schema.Types.ObjectId, ref: 'User', required: true, unique: true },
    profileId: { type: String, unique: true, sparse: true },

    fullName: { type: String, required: true, trim: true },
    gender: { type: String, enum: ['male', 'female'], required: true },
    dateOfBirth: { type: Date, required: true },
    age: { type: Number },
    maritalStatus: {
      type: String,
      enum: ['never_married', 'divorced', 'widowed', 'awaiting_divorce', 'annulled'],
      required: true,
    },
    religion: { type: String, required: true },
    caste: { type: String },
    subCaste: { type: String },
    motherTongue: { type: String },
    bio: { type: String, maxlength: 1000 },

    height: { type: Schema.Types.Mixed },
    weight: { type: Number },
    bodyType: { type: String, enum: ['slim', 'average', 'athletic', 'heavy', 'fit', ''] },
    complexion: { type: String, enum: ['very_fair', 'fair', 'wheatish', 'dark', 'dusky', ''] },
    physicalStatus: { type: String, enum: ['normal', 'physically_challenged', 'disabled', ''] },

    diet: { type: String, enum: ['vegetarian', 'non_vegetarian', 'eggetarian', 'vegan', 'jain', 'pescatarian', ''] },
    smoking: { type: String, enum: ['no', 'occasionally', 'yes', 'never', ''] },
    drinking: { type: String, enum: ['no', 'occasionally', 'yes', 'never', 'social', ''] },
    hobbies: [{ type: String }],
    interests: [{ type: String }],
    languages: [{ type: String }],

    country: { type: String, required: true },
    state: { type: String },
    city: { type: String, required: true },
    citizenship: { type: String },
    residencyStatus: {
      type: String,
      enum: ['citizen', 'permanent_resident', 'work_permit', 'student_visa', 'temporary_visa', 'work_visa', 'pr', ''],
    },

    education: {
      type: String,
      enum: [
        'high_school', 'diploma', 'bachelors', 'masters', 'doctorate', 'phd',
        'undergraduate', 'graduate', 'post_graduate', 'professional', 'trade_school',
        'associate', 'mba', 'medical', 'engineering', 'law', 'ca', 'other', '',
      ],
    },
    educationField: { type: String },
    institution: { type: String },
    occupation: { type: String },
    employmentType: {
      type: String,
      enum: [
        'employed', 'self_employed', 'business', 'not_working', 'student',
        'government', 'private', 'public_sector', 'private_sector', 'defence',
        'civil_services', 'freelancer', 'consultant', 'entrepreneur', 'professional',
        'retired', 'homemaker', 'unemployed', '',
      ],
    },
    company: { type: String },
    jobTitle: { type: String },
    annualIncome: {
      type: String,
      enum: [
        'below_2l', '2l_5l', '5l_10l', '10l_15l', '15l_25l', '25l_50l', '50l_1cr', 'above_1cr',
        'below_25k', '25k_50k', '50k_75k', '75k_100k', '100k_150k', '150k_200k', 'above_200k',
        'not_disclosed', 'prefer_not_to_say', '',
      ],
    },

    fatherName: { type: String },
    fatherOccupation: { type: String },
    motherName: { type: String },
    motherOccupation: { type: String },
    siblings: { type: Number },
    familyType: { type: String, enum: ['joint', 'nuclear', 'other', ''] },
    familyStatus: { type: String, enum: ['middle_class', 'upper_middle_class', 'rich', 'affluent', 'lower_middle_class', ''] },
    familyValues: { type: String, enum: ['traditional', 'moderate', 'liberal', 'orthodox', ''] },

    photos: [photoSchema],

    partnerPreferences: {
      ageRange: { min: { type: Number, default: 18 }, max: { type: Number, default: 60 } },
      heightRange: { min: { type: Number, default: 120 }, max: { type: Number, default: 220 } },
      religion: [{ type: String }],
      caste: [{ type: String }],
      motherTongue: [{ type: String }],
      education: [{ type: String }],
      occupation: [{ type: String }],
      annualIncome: [{ type: String }],
      maritalStatus: [{ type: String }],
      diet: [{ type: String }],
      smoking: [{ type: String }],
      drinking: [{ type: String }],
      country: [{ type: String }],
      state: [{ type: String }],
      city: [{ type: String }],
      aboutPartner: { type: String, maxlength: 1000 },
    },

    privacySettings: {
      showPhone: { type: Boolean, default: false },
      showEmail: { type: Boolean, default: false },
      showIncome: { type: Boolean, default: false },
      photoVisibility: { type: String, enum: ['all', 'matches', 'premium', 'none', 'connected'], default: 'all' },
      profileVisibility: { type: String, enum: ['all', 'matches', 'premium', 'none', 'registered'], default: 'all' },
    },

    profileViews: { type: Number, default: 0 },
    completionPercentage: { type: Number, default: 0 },
    // ✅ FIX: Added completionDetails field to persist breakdown
    completionDetails: { type: Schema.Types.Mixed, default: {} },

    isActive: { type: Boolean, default: true },
    isVerified: { type: Boolean, default: false },
    verifiedAt: { type: Date },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

profileSchema.index({ userId: 1 });
profileSchema.index({ profileId: 1 });
profileSchema.index({ gender: 1, age: 1 });
profileSchema.index({ religion: 1 });
profileSchema.index({ country: 1, city: 1 });
profileSchema.index({ isActive: 1 });

profileSchema.virtual('displayHeight').get(function () {
  if (!this.height) return null;
  if (typeof this.height === 'object' && this.height.feet) {
    return `${this.height.feet}'${this.height.inches || 0}"`;
  }
  if (typeof this.height === 'number') {
    const totalInches = Math.round(this.height / 2.54);
    const feet = Math.floor(totalInches / 12);
    const inches = totalInches % 12;
    return `${feet}'${inches}"`;
  }
  return null;
});

export default model('Profile', profileSchema);===== FILE: ./models/Payment.js =====
// ===== FILE: ./models/Payment.js =====
import mongoose from 'mongoose';
const { Schema } = mongoose;

const paymentSchema = new Schema(
  {
    userId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
    subscriptionId: { type: Schema.Types.ObjectId, ref: 'Subscription' },

    // Stripe data
    stripePaymentIntentId: String,
    stripeChargeId: String,
    stripeInvoiceId: String,
    stripeReceiptUrl: String,

    // Payment details (store major units here: 9.99 USD, 1000 JPY, etc.)
    amount: { type: Number, required: true },
    // Store Stripe integer amount (minor units) when available
    amountMinor: { type: Number },

    currency: { type: String, required: true, default: 'USD' }, // uppercase recommended

    plan: { type: String, enum: ['free', 'monthly', 'yearly', 'contact_unlock'] },

    status: {
      type: String,
      enum: ['pending', 'processing', 'succeeded', 'failed', 'refunded', 'cancelled'],
      default: 'pending',
    },

    paymentMethod: {
      type: { type: String }, // card, upi, netbanking, etc.
      last4: String,
      brand: String,
      expiryMonth: Number,
      expiryYear: Number,
    },

    description: String,
    metadata: Schema.Types.Mixed,

    refundedAmount: { type: Number, default: 0 },
    refundReason: String,
    refundedAt: Date,

    failureCode: String,
    failureMessage: String,
  },
  { timestamps: true }
);

paymentSchema.index({ userId: 1, createdAt: -1 });
paymentSchema.index({ stripePaymentIntentId: 1 });
paymentSchema.index({ stripeInvoiceId: 1 });
paymentSchema.index({ status: 1 });

export default mongoose.model('Payment', paymentSchema);===== FILE: ./utils/uploadToCloudinary.js =====
import fs from 'fs';
import path from 'path';
import cloudinary, { hasCloudinary } from '../config/cloudinary.js';

const uploadToCloudinary = async (filePath, folder = 'matrimony') => {
  // fallback to local
  if (!hasCloudinary) {
    return { url: `/uploads/${path.basename(filePath)}`, publicId: null };
  }

  const result = await cloudinary.uploader.upload(filePath, { folder });
  try { fs.unlinkSync(filePath); } catch {}
  return { url: result.secure_url, publicId: result.public_id };
};

export default uploadToCloudinary;===== FILE: ./utils/relationship.js =====
import Interest from '../models/Interest.js';

export const isMatchBetween = async (userA, userB) => {
  if (!userA || !userB) return false;
  const a = userA.toString();
  const b = userB.toString();
  const found = await Interest.exists({
    status: 'accepted',
    $or: [
      { senderId: a, receiverId: b },
      { senderId: b, receiverId: a },
    ],
  });
  return !!found;
};===== FILE: ./utils/pagination.js =====
// ===== FILE: ./utils/pagination.js =====

import { LIMITS } from './constants.js';

/**
 * Parse pagination parameters from query string
 * @param {Object} query - Express req.query object
 * @param {Object} options - Custom options
 * @returns {Object} Parsed pagination values
 */
export const parsePagination = (query, options = {}) => {
  const {
    maxLimit = LIMITS.MAX_LIMIT,
    defaultLimit = LIMITS.DEFAULT_LIMIT,
    defaultPage = LIMITS.DEFAULT_PAGE,
  } = options;

  const page = Math.max(1, parseInt(query.page, 10) || defaultPage);
  const limit = Math.min(
    maxLimit,
    Math.max(1, parseInt(query.limit, 10) || defaultLimit)
  );
  const skip = (page - 1) * limit;

  return { page, limit, skip };
};

/**
 * Format pagination response
 * @param {number} total - Total count of documents
 * @param {number} page - Current page
 * @param {number} limit - Items per page
 * @returns {Object} Formatted pagination object
 */
export const formatPaginationResponse = (total, page, limit) => {
  const pages = Math.ceil(total / limit);

  return {
    total,
    page,
    limit,
    pages,
    hasNext: page < pages,
    hasPrev: page > 1,
  };
};

/**
 * Combined helper for pagination
 * @param {Object} query - Express req.query
 * @param {number} total - Total document count
 * @param {Object} options - Custom options
 * @returns {Object} { page, limit, skip, pagination }
 */
export const getPagination = (query, total, options = {}) => {
  const { page, limit, skip } = parsePagination(query, options);
  const pagination = formatPaginationResponse(total, page, limit);

  return { page, limit, skip, pagination };
};

export default {
  parsePagination,
  formatPaginationResponse,
  getPagination,
};===== FILE: ./utils/phoneCountries.js =====
import { getCountries, getCountryCallingCode } from 'libphonenumber-js';

const displayNames =
  typeof Intl !== 'undefined' && Intl.DisplayNames
    ? new Intl.DisplayNames(['en'], { type: 'region' })
    : null;

const isoToFlagEmoji = (iso2) => {
  if (!iso2 || iso2.length !== 2) return '';
  const codePoints = iso2
    .toUpperCase()
    .split('')
    .map((c) => 127397 + c.charCodeAt(0));
  return String.fromCodePoint(...codePoints);
};

export const PHONE_COUNTRIES = getCountries()
  .map((iso2) => {
    const callingCode = getCountryCallingCode(iso2);
    return {
      iso2,
      name: displayNames ? displayNames.of(iso2) : iso2,
      callingCode: `+${callingCode}`,
      flag: isoToFlagEmoji(iso2),
    };
  })
  .sort((a, b) => {
    if (a.iso2 === 'IN') return -1;
    if (b.iso2 === 'IN') return 1;
    return a.name.localeCompare(b.name);
  });===== FILE: ./utils/errors.js =====
// ===== FILE: ./utils/errors.js =====

export class AppError extends Error {
  constructor(message, statusCode, code = null) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = true;
    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message, errors = []) {
    super(message, 400, 'VALIDATION_ERROR');
    this.errors = errors;
  }
}

export class AuthenticationError extends AppError {
  constructor(message = 'Authentication required') {
    super(message, 401, 'AUTHENTICATION_ERROR');
  }
}

export class AuthorizationError extends AppError {
  constructor(message = 'Access denied') {
    super(message, 403, 'AUTHORIZATION_ERROR');
  }
}

export class NotFoundError extends AppError {
  constructor(resource = 'Resource') {
    super(`${resource} not found`, 404, 'NOT_FOUND');
  }
}

export class ConflictError extends AppError {
  constructor(message = 'Resource already exists') {
    super(message, 409, 'CONFLICT');
  }
}

export class RateLimitError extends AppError {
  constructor(message = 'Too many requests') {
    super(message, 429, 'RATE_LIMIT_EXCEEDED');
  }
}

/**
 * Standardized error handler for controllers
 * @param {Response} res - Express response object
 * @param {Error} error - Error object
 * @param {string} context - Context for logging (e.g., 'Search profiles')
 */
export const handleControllerError = (res, error, context = 'Operation') => {
  // Log error with context
  console.error(`${context} error:`, {
    message: error.message,
    stack: process.env.NODE_ENV !== 'production' ? error.stack : undefined,
    code: error.code,
  });

  // Handle known operational errors
  if (error.isOperational) {
    return res.status(error.statusCode).json({
      message: error.message,
      code: error.code,
      ...(error.errors && { errors: error.errors }),
    });
  }

  // Handle Mongoose validation errors
  if (error.name === 'ValidationError') {
    const errors = Object.values(error.errors).map((e) => ({
      field: e.path,
      message: e.message,
    }));
    return res.status(400).json({
      message: 'Validation failed',
      code: 'VALIDATION_ERROR',
      errors,
    });
  }

  // Handle Mongoose duplicate key error
  if (error.code === 11000) {
    const field = Object.keys(error.keyPattern || {})[0] || 'field';
    return res.status(409).json({
      message: `Duplicate value for ${field}`,
      code: 'DUPLICATE_KEY',
    });
  }

  // Handle Mongoose CastError (invalid ObjectId)
  if (error.name === 'CastError') {
    return res.status(400).json({
      message: `Invalid ${error.path}: ${error.value}`,
      code: 'INVALID_ID',
    });
  }

  // Handle JWT errors
  if (error.name === 'JsonWebTokenError') {
    return res.status(401).json({
      message: 'Invalid token',
      code: 'INVALID_TOKEN',
    });
  }

  if (error.name === 'TokenExpiredError') {
    return res.status(401).json({
      message: 'Token expired',
      code: 'TOKEN_EXPIRED',
    });
  }

  // Generic server error - don't expose details in production
  return res.status(500).json({
    message: 'An unexpected error occurred',
    code: 'INTERNAL_ERROR',
    ...(process.env.NODE_ENV !== 'production' && { debug: error.message }),
  });
};

export default {
  AppError,
  ValidationError,
  AuthenticationError,
  AuthorizationError,
  NotFoundError,
  ConflictError,
  RateLimitError,
  handleControllerError,
};===== FILE: ./utils/constants.js =====
export const LIMITS = {
  MAX_MESSAGE_LENGTH: 2000,
  MAX_INTEREST_MESSAGE: 200,
  MAX_BIO_LENGTH: 1000,
  MAX_DESCRIPTION_LENGTH: 500,
  MAX_RESOLUTION_NOTE: 1000,
  MAX_NAME_LENGTH: 100,
  MAX_REASON_LENGTH: 500,

  MAX_PHOTOS: 6, // aligned with UI + upload middleware
  MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB

  DEFAULT_PAGE: 1,
  DEFAULT_LIMIT: 20,
  MAX_LIMIT: 200,
  MAX_LIMIT_SEARCH: 100,
};

export const OTP = {
  EXPIRY_MINUTES: 10,
  LENGTH: 6,
};

export const TOKEN_EXPIRY = {
  ACCESS_TOKEN: '7d',
  EMAIL_VERIFICATION: 60 * 60 * 1000,
  PASSWORD_RESET: 60 * 60 * 1000,
  PHONE_OTP: 10 * 60 * 1000,
};

export const CLEANUP_INTERVAL = 60000;

export const REPORT_TYPES = [
  'fake_profile',
  'inappropriate_behavior',
  'harassment',
  'inappropriate_content',
  'scam',
  'offensive_language',
  'other',
];

export const REPORT_ACTIONS = ['none', 'warning', 'suspension', 'deletion'];

export const SUBSCRIPTION_PLANS = ['free', 'monthly', 'yearly'];

export const MARITAL_STATUSES = [
  'never_married',
  'divorced',
  'widowed',
  'awaiting_divorce',
  'annulled',
];

export const GENDERS = ['male', 'female'];

export const DIET_OPTIONS = [
  'vegetarian',
  'non_vegetarian',
  'eggetarian',
  'vegan',
  'jain',
  'pescatarian',
];

export const BODY_TYPES = ['slim', 'average', 'athletic', 'heavy', 'fit'];===== FILE: ./utils/privacy.js =====
// ===== UPDATED FILE: ./utils/privacy.js =====
import { hasPremiumAccess } from './entitlements.js';

const canSeePhotosByVisibility = ({ photoVisibility, isOwn, isPremium, isMatch }) => {
  if (isOwn) return true;

  const v = photoVisibility || 'all';
  if (v === 'all') return true;
  if (v === 'none') return false;
  if (v === 'premium') return isPremium;
  if (v === 'connected' || v === 'matches') return isMatch;
  return false;
};

const canSeeProfileByVisibility = ({ profileVisibility, isOwn, isPremium, isMatch, isRegistered }) => {
  if (isOwn) return true;

  const v = profileVisibility || 'all';
  if (v === 'all') return true;
  if (v === 'none') return false;
  if (v === 'registered') return isRegistered;
  if (v === 'premium') return isPremium;
  if (v === 'matches') return isMatch;
  return false;
};

export const applyProfilePrivacy = ({ viewer, profile, isMatch = false }) => {
  const result = { ...profile };

  const viewerId = viewer?._id?.toString?.();
  const ownerId = profile.userId?._id?.toString?.() || profile.userId?.toString?.();
  const isOwn = !!(viewerId && ownerId && viewerId === ownerId);

  const isPremium = hasPremiumAccess(viewer);
  const isRegistered = !!viewer;
  const ps = profile.privacySettings || {};

  const canSeeProfile = canSeeProfileByVisibility({
    profileVisibility: ps.profileVisibility,
    isOwn,
    isPremium,
    isMatch,
    isRegistered,
  });

  if (!canSeeProfile) {
    return {
      _id: profile._id,
      userId: profile.userId,
      profileId: profile.profileId,
      profileLocked: true,
      viewerContext: { isOwn, isPremiumViewer: isPremium, isMatch, isRegistered },
    };
  }

  const canSeePhone = isOwn || ps.showPhone === true;
  const canSeeEmail = isOwn || ps.showEmail === true;
  const canSeeIncome = isOwn || ps.showIncome === true;

  if (result.userId && typeof result.userId === 'object') {
    if (!canSeePhone) {
      delete result.userId.phone;
      delete result.userId.countryCode;
    }
    if (!canSeeEmail) {
      delete result.userId.email;
    }
  }

  if (!canSeeEmail) {
    delete result.email;
  }

  if (!canSeeIncome) {
    delete result.annualIncome;
  }

  const canSeePhotos = canSeePhotosByVisibility({
    photoVisibility: ps.photoVisibility,
    isOwn,
    isPremium,
    isMatch,
  });

  if (!canSeePhotos) {
    result.photos = [];
    result.photosLocked = true;
    if ('photoUrl' in result) result.photoUrl = null;
  }

  result.viewerContext = { isOwn, isPremiumViewer: isPremium, isMatch, isRegistered };
  return result;
};===== FILE: ./utils/entitlements.js =====
// ===== FIXED FILE: ./utils/entitlements.js =====
export const hasPremiumAccess = (user) => {
  if (!user) return false;

  const endDate = user.subscription?.endDate ? new Date(user.subscription.endDate) : null;

  const subActive =
    user.subscription?.isActive === true &&
    endDate instanceof Date &&
    !Number.isNaN(endDate.valueOf()) &&
    new Date() < endDate;

  const hasPaidSnapshot =
    user.subscription?.plan === 'monthly' ||
    user.subscription?.plan === 'yearly' ||
    !!user.subscription?.endDate;

  if (hasPaidSnapshot) return subActive;

  // ✅ FIX: Only trust premiumExpiry if it exists AND is in the future
  if (user.premiumExpiry && new Date() < new Date(user.premiumExpiry)) return true;

  // ✅ FIX: Only trust isPremium if premiumExpiry exists and is valid
  // Bare isPremium without expiry should NOT grant access (prevents stale flag)
  if (user.isPremium && user.premiumExpiry) {
    return new Date() < new Date(user.premiumExpiry);
  }

  return false;
};

export const isSubscriptionExpired = (user) => {
  if (!user?.subscription?.endDate) return true;
  return new Date() >= new Date(user.subscription.endDate);
};

export const getSubscriptionDaysRemaining = (user) => {
  if (!user?.subscription?.endDate) return 0;
  const end = new Date(user.subscription.endDate);
  const now = new Date();
  if (now >= end) return 0;
  return Math.ceil((end - now) / (1000 * 60 * 60 * 24));
};===== FILE: ./utils/currency.js =====
// ===== FILE: ./utils/currency.js =====

// Country code to currency mapping
export const countryCodeToCurrency = {
  '+1': { currency: 'USD', symbol: '$', country: 'United States' },
  '+7': { currency: 'RUB', symbol: '₽', country: 'Russia' },
  '+20': { currency: 'EGP', symbol: 'E£', country: 'Egypt' },
  '+27': { currency: 'ZAR', symbol: 'R', country: 'South Africa' },
  '+30': { currency: 'EUR', symbol: '€', country: 'Greece' },
  '+31': { currency: 'EUR', symbol: '€', country: 'Netherlands' },
  '+32': { currency: 'EUR', symbol: '€', country: 'Belgium' },
  '+33': { currency: 'EUR', symbol: '€', country: 'France' },
  '+34': { currency: 'EUR', symbol: '€', country: 'Spain' },
  '+39': { currency: 'EUR', symbol: '€', country: 'Italy' },
  '+40': { currency: 'RON', symbol: 'lei', country: 'Romania' },
  '+41': { currency: 'CHF', symbol: 'CHF', country: 'Switzerland' },
  '+43': { currency: 'EUR', symbol: '€', country: 'Austria' },
  '+44': { currency: 'GBP', symbol: '£', country: 'United Kingdom' },
  '+45': { currency: 'DKK', symbol: 'kr', country: 'Denmark' },
  '+46': { currency: 'SEK', symbol: 'kr', country: 'Sweden' },
  '+47': { currency: 'NOK', symbol: 'kr', country: 'Norway' },
  '+48': { currency: 'PLN', symbol: 'zł', country: 'Poland' },
  '+49': { currency: 'EUR', symbol: '€', country: 'Germany' },
  '+52': { currency: 'MXN', symbol: '$', country: 'Mexico' },
  '+55': { currency: 'BRL', symbol: 'R$', country: 'Brazil' },
  '+60': { currency: 'MYR', symbol: 'RM', country: 'Malaysia' },
  '+61': { currency: 'AUD', symbol: 'A$', country: 'Australia' },
  '+62': { currency: 'IDR', symbol: 'Rp', country: 'Indonesia' },
  '+63': { currency: 'PHP', symbol: '₱', country: 'Philippines' },
  '+64': { currency: 'NZD', symbol: 'NZ$', country: 'New Zealand' },
  '+65': { currency: 'SGD', symbol: 'S$', country: 'Singapore' },
  '+66': { currency: 'THB', symbol: '฿', country: 'Thailand' },
  '+81': { currency: 'JPY', symbol: '¥', country: 'Japan' },
  '+82': { currency: 'KRW', symbol: '₩', country: 'South Korea' },
  '+84': { currency: 'VND', symbol: '₫', country: 'Vietnam' },
  '+86': { currency: 'CNY', symbol: '¥', country: 'China' },
  '+90': { currency: 'TRY', symbol: '₺', country: 'Turkey' },
  '+91': { currency: 'INR', symbol: '₹', country: 'India' },
  '+92': { currency: 'PKR', symbol: '₨', country: 'Pakistan' },
  '+94': { currency: 'LKR', symbol: 'Rs', country: 'Sri Lanka' },
  '+212': { currency: 'MAD', symbol: 'د.م.', country: 'Morocco' },
  '+234': { currency: 'NGN', symbol: '₦', country: 'Nigeria' },
  '+254': { currency: 'KES', symbol: 'KSh', country: 'Kenya' },
  '+380': { currency: 'UAH', symbol: '₴', country: 'Ukraine' },
  '+420': { currency: 'CZK', symbol: 'Kč', country: 'Czech Republic' },
  '+852': { currency: 'HKD', symbol: 'HK$', country: 'Hong Kong' },
  '+880': { currency: 'BDT', symbol: '৳', country: 'Bangladesh' },
  '+886': { currency: 'TWD', symbol: 'NT$', country: 'Taiwan' },
  '+966': { currency: 'SAR', symbol: '﷼', country: 'Saudi Arabia' },
  '+971': { currency: 'AED', symbol: 'د.إ', country: 'UAE' },
  '+972': { currency: 'ILS', symbol: '₪', country: 'Israel' },
  '+973': { currency: 'BHD', symbol: '.د.ب', country: 'Bahrain' },
  '+974': { currency: 'QAR', symbol: '﷼', country: 'Qatar' },
  '+977': { currency: 'NPR', symbol: '₨', country: 'Nepal' },
};

// Base prices in USD
export const basePricesUSD = {
  free: 0,
  monthly: 9.99,
  yearly: 99.99,
};

// Approx exchange rates (production: use real FX API)
export const exchangeRates = {
  USD: 1,
  EUR: 0.92,
  GBP: 0.79,
  INR: 83.12,
  AED: 3.67,
  SAR: 3.75,
  AUD: 1.53,
  CAD: 1.36,
  SGD: 1.34,
  MYR: 4.47,
  THB: 35.5,
  IDR: 15700,
  PHP: 56.5,
  VND: 24500,
  JPY: 149,
  KRW: 1320,
  CNY: 7.24,
  HKD: 7.82,
  TWD: 31.5,
  PKR: 278,
  BDT: 110,
  LKR: 320,
  NPR: 133,
  BRL: 4.97,
  MXN: 17.2,
  ZAR: 18.5,
  NGN: 1550,
  KES: 153,
  EGP: 30.9,
  TRY: 32.5,
  RUB: 92,
  PLN: 4.02,
  CZK: 22.8,
  SEK: 10.5,
  NOK: 10.8,
  DKK: 6.87,
  CHF: 0.88,
  NZD: 1.64,
  QAR: 3.64,
  BHD: 0.377,
  ILS: 3.65,
  UAH: 37.5,
  RON: 4.57,
};

// Stripe minor-unit rules (important for correct amounts)
export const ZERO_DECIMAL_CURRENCIES = new Set([
  'BIF','CLP','DJF','GNF','JPY','KMF','KRW','MGA','PYG','RWF','UGX','VND','VUV','XAF','XOF','XPF',
]);
export const THREE_DECIMAL_CURRENCIES = new Set(['BHD','JOD','KWD','OMR','TND']);

export const getMinorUnitMultiplier = (currency) => {
  const c = String(currency || '').toUpperCase();
  if (ZERO_DECIMAL_CURRENCIES.has(c)) return 1;
  if (THREE_DECIMAL_CURRENCIES.has(c)) return 1000;
  return 100; // default 2-decimal
};

export const toMinorUnits = (amountMajor, currency) => {
  const m = getMinorUnitMultiplier(currency);
  // Stripe requires integer minor units
  return Math.round(Number(amountMajor) * m);
};

export const toMajorUnits = (amountMinor, currency) => {
  const m = getMinorUnitMultiplier(currency);
  return Number(amountMinor) / m;
};

// A conservative allow-list. If currency not here, we fallback to USD for charging.
export const stripeSupportedCurrencies = [
  'usd','eur','gbp','inr','aed','sar','qar','bhd','aud','cad','sgd','myr','thb','idr','php',
  'jpy','krw','vnd','cny','hkd','twd','brl','mxn','zar','try','egp','pln','czk','sek','nok','dkk','chf','nzd','ils','uah','ron','rub'
];

export const isStripeSupportedCurrency = (currency) =>
  stripeSupportedCurrencies.includes(String(currency || '').toLowerCase());

// Get currency info from country code
export const getCurrencyFromCountryCode = (countryCode) => {
  const info = countryCodeToCurrency[countryCode];
  return info || { currency: 'USD', symbol: '$', country: 'Unknown' };
};

// Convert USD price to target currency (major units)
export const convertPrice = (priceUSD, targetCurrency) => {
  const c = String(targetCurrency || 'USD').toUpperCase();
  const rate = exchangeRates[c] || 1;
  const converted = Number(priceUSD) * rate;

  // Round to the right decimals for that currency
  const mult = getMinorUnitMultiplier(c);
  return Math.round(converted * mult) / mult;
};

// Get prices in a specific currency for display
export const getPricesInCurrency = (currency) => {
  const currencyUpper = String(currency || 'USD').toUpperCase();
  const info =
    Object.values(countryCodeToCurrency).find((c) => c.currency === currencyUpper) || {
      symbol: '$',
      currency: 'USD',
    };

  const monthly = convertPrice(basePricesUSD.monthly, currencyUpper);
  const yearly = convertPrice(basePricesUSD.yearly, currencyUpper);

  return {
    currency: currencyUpper,
    symbol: info.symbol,
    free: { price: 0, display: `${info.symbol}0` },
    monthly: { price: monthly, display: `${info.symbol}${monthly}` },
    yearly: {
      price: yearly,
      display: `${info.symbol}${yearly}`,
      savings: Math.round((1 - basePricesUSD.yearly / (basePricesUSD.monthly * 12)) * 100),
    },
  };
};

// Get Stripe-compatible currency (fallback to USD if not supported)
export const getStripeCurrency = (currency) => {
  const c = String(currency || 'USD').toLowerCase();
  return isStripeSupportedCurrency(c) ? c : 'usd';
};===== FILE: ./utils/calculateMatchScore.js =====
const norm = (v) => String(v || '').trim().toLowerCase();

const calculateMatchScore = (userProfile, candidateProfile) => {
  let score = 0;
  let totalCriteria = 0;
  const prefs = userProfile.partnerPreferences || {};

  if (prefs.ageRange?.min != null && prefs.ageRange?.max != null) {
    totalCriteria += 10;
    if (candidateProfile.age >= prefs.ageRange.min && candidateProfile.age <= prefs.ageRange.max) score += 10;
  }

  if (prefs.religion?.length) {
    totalCriteria += 15;
    const prefSet = new Set(prefs.religion.map(norm));
    if (prefSet.has(norm(candidateProfile.religion))) score += 15;
  }

  if (prefs.education?.length) {
    totalCriteria += 10;
    const prefSet = new Set(prefs.education.map(norm));
    if (prefSet.has(norm(candidateProfile.education))) score += 10;
  }

  if (prefs.country?.length) {
    totalCriteria += 10;
    const prefSet = new Set(prefs.country.map(norm));
    if (prefSet.has(norm(candidateProfile.country))) score += 10;
  }

  if (prefs.diet?.length) {
    totalCriteria += 5;
    const prefSet = new Set(prefs.diet.map(norm));
    if (prefSet.has(norm(candidateProfile.diet))) score += 5;
  }

  return totalCriteria ? Math.round((score / totalCriteria) * 100) : 0;
};

export default calculateMatchScore;===== FILE: ./middleware/optionalAuth.js =====
// ===== FILE: ./middleware/optionalAuth.js =====
// Backwards-compatible wrapper.
// Source of truth is middleware/authMiddleware.js
import { optionalAuth as optionalAuthMiddleware } from './authMiddleware.js';

export default optionalAuthMiddleware;===== FILE: ./middleware/validate.js =====
import { validationResult } from 'express-validator';

export const handleValidation = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ 
      message: 'Validation failed',
      errors: errors.array() 
    });
  }
  next();
};===== FILE: ./middleware/errorHandler.js =====
// ===== FIXED FILE: ./middleware/errorHandler.js =====
const errorHandler = (err, req, res, next) => {
  // ✅ FIX: If headers already sent, delegate to Express default handler
  if (res.headersSent) {
    return next(err);
  }

  console.error('ERROR:', err);
  const statusCode = res.statusCode && res.statusCode !== 200 ? res.statusCode : 500;
  res.status(statusCode).json({
    message: err.message || 'Server Error',
    stack: process.env.NODE_ENV === 'production' ? undefined : err.stack,
  });
};

export default errorHandler;===== FILE: ./middleware/uploadMiddleware.js =====
import multer from 'multer';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import { LIMITS } from '../utils/constants.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const uploadsDir = path.join(__dirname, '..', 'uploads');
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadsDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1E9)}`;
    const ext = path.extname(file.originalname);
    cb(null, `${file.fieldname}-${uniqueSuffix}${ext}`);
  },
});

const fileFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png|gif|webp/;
  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname && mimetype) {
    cb(null, true);
  } else {
    cb(new Error('Only image files (jpeg, jpg, png, gif, webp) are allowed'), false);
  }
};

const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: LIMITS.MAX_FILE_SIZE,
    files: LIMITS.MAX_PHOTOS,
  },
});

export default upload;===== FILE: ./middleware/authMiddleware.js =====
// ===== FILE: ./middleware/authMiddleware.js =====
import jwt from 'jsonwebtoken';
import User from '../models/User.js';

/**
 * Protect routes - require authentication
 */
export const protect = async (req, res, next) => {
  try {
    let token;

    // Get token from header or cookies
    if (req.headers.authorization?.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    } else if (req.cookies?.accessToken) {
      token = req.cookies.accessToken;
    }

    if (!token) {
      return res.status(401).json({
        message: 'Not authorized, no token',
        code: 'NO_TOKEN',
      });
    }

    // Verify token
    const secret = process.env.JWT_SECRET;
    if (!secret) {
      console.error('JWT_SECRET not configured');
      return res.status(500).json({
        message: 'Server configuration error',
        code: 'CONFIG_ERROR',
      });
    }

    const decoded = jwt.verify(token, secret);

    // Get user from token
    const user = await User.findById(decoded.id).select('-password -refreshToken');

    if (!user) {
      return res.status(401).json({
        message: 'User not found',
        code: 'USER_NOT_FOUND',
      });
    }

    // Check if user is suspended
    if (user.isSuspended) {
      return res.status(403).json({
        message: 'Account suspended',
        code: 'ACCOUNT_SUSPENDED',
        reason: user.suspensionReason,
      });
    }

    // Check if user is active
    if (user.isActive === false) {
      return res.status(403).json({
        message: 'Account inactive',
        code: 'ACCOUNT_INACTIVE',
      });
    }

    // Attach user to request
    req.user = user;
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        message: 'Token expired',
        code: 'TOKEN_EXPIRED',
      });
    }

    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({
        message: 'Invalid token',
        code: 'INVALID_TOKEN',
      });
    }

    console.error('Auth middleware error:', error);
    return res.status(401).json({
      message: 'Not authorized',
      code: 'AUTH_ERROR',
    });
  }
};

/**
 * Optional auth - attach user if token exists, but don't require it
 */
export const optionalAuth = async (req, res, next) => {
  try {
    let token;

    if (req.headers.authorization?.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    } else if (req.cookies?.accessToken) {
      token = req.cookies.accessToken;
    }

    if (token) {
      const secret = process.env.JWT_SECRET;
      if (secret) {
        const decoded = jwt.verify(token, secret);
        const user = await User.findById(decoded.id).select('-password -refreshToken');
        if (user && !user.isSuspended) {
          req.user = user;
        }
      }
    }

    next();
  } catch (error) {
    // Silently continue without user
    next();
  }
};

/**
 * Admin only routes
 */
export const admin = async (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({
      message: 'Not authorized',
      code: 'NO_AUTH',
    });
  }

  if (req.user.role !== 'admin' && req.user.role !== 'superadmin') {
    return res.status(403).json({
      message: 'Admin access required',
      code: 'NOT_ADMIN',
    });
  }

  next();
};

export default { protect, optionalAuth, admin };===== FILE: ./middleware/admin.js =====
// ===== FILE: ./middleware/admin.js =====
// Backwards-compatible wrapper.
// Source of truth is middleware/authMiddleware.js
import { admin as adminMiddleware } from './authMiddleware.js';

export default adminMiddleware;===== FILE: ./middleware/rateLimiter.js =====
// ===== FIXED FILE: server/middleware/rateLimiter.js =====
import rateLimit from 'express-rate-limit';

const isDev = process.env.NODE_ENV !== 'production';

// ✅ FIX: Removed redundant `skip` — apiLimiter is already conditionally mounted in server.js
export const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: {
    message: 'Too many requests, please try again later',
    retryAfter: 15,
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// ✅ FIX: Auth limiter still needs skip for dev since it's always mounted
export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: isDev ? 100 : 10,
  message: {
    message: 'Too many authentication attempts, please try again later',
    retryAfter: 15,
  },
  standardHeaders: true,
  legacyHeaders: false,
  skip: () => isDev,
});

export const strictLimiter = rateLimit({
  windowMs: 60 * 60 * 1000,
  max: isDev ? 100 : 5,
  message: {
    message: 'Too many attempts, please try again later',
    retryAfter: 60,
  },
  standardHeaders: true,
  legacyHeaders: false,
  skip: () => isDev,
});

export default { apiLimiter, authLimiter, strictLimiter };